{"pages":[{"title":"about","text":"华东师范大学软件工程学生一名，目前大三了，感概自己一事无成。开个博客，以后把自己学习上的东西传一传吧。也算是对大学生活的一个交代了。","link":"/about/index.html"}],"posts":[{"title":"正确配置hexo环境变量","text":"最近在 $windows$ 上搭建了 $Hexo$ 博客，出师未捷身先死吧，在配置环境变量的时候总是出问题，看了好几篇别人的博客也无济于事。最后我想，要使用 $Hexo$ 指令，应该是将一个带有 $.exe$ 后缀的文件路径加入到 $Path$ 中，于是我使用万能的 $Everything$ 搜索了 $hexo$，于是找到了 $hexo.cmd$$Windows$ 用户应该只要将这个路径加入到系统变量中的 $Path$ 即可正常使用了。","link":"/2020/06/17/%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEhexo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"title":"暑期自训 $1$","text":"$A.\\ CF1236A$纯签 $B.\\ CF1236B$题意：有 $n$ 种礼物，每种礼物数量无限。$m$ 个可区分盒子。至少有一个盒子有礼物且每种礼物最少都要放一个。问有多少种方法。 思路：对每种礼物进行考虑，盒子有该礼物和没该礼物两种状态，这样每个盒子都能用 $0$ 和 $1$ 来表示两种状态。因为不能全空，这个时候就有 $2^m-1$ 种情况；再来考虑放礼物。不难发现，对于每个盒子来说，可以装这个礼物也可以不装，所以答案就是 $(2^m-1)^n$ 123456789101112131415161718192021222324252627282930313233343536#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i >= 1; a *= a, a %= mod; } return ans;}int main(){ cin >> n >> m; LL ans = qpow(qpow(2, m) - 1, n); cout < ans < n; int ans[maxn][maxn]; int m = n, cnt = 0; for(int i = 0; i < n; ++i) { if(i % 2 == 0) { for(int j = 0; j < n; ++j) ans[j][i] = ++cnt; } else for(int j = n - 1; j >= 0; --j) ans[j][i] = ++cnt; } for(int i = 0; i < n; ++i) for(int j = 0; j < n; ++j) printf(\"%d%c\", ans[i][j], (j == n - 1) ? '\\n' : ' '); return 0;} $G\\ CF1244A$纯签 $H\\ CF1244B$题意：两层迷宫，平行位置可以互相来往，当该位置为 $1$ 时，可以上下行走，每个格子最多走一次。问能走最多的格子的数量。 思路：当 $s[0]=’1’$ 或者 $s[n-1]=’1’$ 时，可以走完所有的格子，进而继续推导，能走多少个格子取决于的两端的 $1$ 的位置。 12345678910111213141516171819202122232425262728293031323334353637383940#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { cin >> n; cin >> s; int ans = 0; int flag = 0; vector v; for(int i = 0; i < n; ++i) if(s[i] == '1') v.push_back(i); if(!v.size()) ans = n; else { ans = max(2 * (v[0] + 1), 2 * (v.back() + 1)); ans = max(ans, 2 * (n - v[0])); ans = max(ans, 2 * (n - v.back())); } cout < ans < x >> y; d[x]++; d[y]++; if(d[x] > 2) flag = false; if(d[y] > 2) flag = false; v[x].pb(y); v[y].pb(x); } if(!flag) { puts(\"-1\"); return 0; } for(int i = 1; i","link":"/2020/06/25/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD1/"}],"tags":[{"name":"Environment configuration","slug":"Environment-configuration","link":"/tags/Environment-configuration/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"}],"categories":[{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"ACM","slug":"ACM","link":"/categories/ACM/"}]}