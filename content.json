{"pages":[{"title":"about","text":"华东师范大学软件工程学生一名，目前大三了，感概自己一事无成。开个博客，以后把自己学习上的东西传一传吧。也算是对大学生活的一个交代了。","link":"/about/index.html"}],"posts":[{"title":"正确配置hexo环境变量","text":"最近在 $windows$ 上搭建了 $Hexo$ 博客，出师未捷身先死吧，在配置环境变量的时候总是出问题，看了好几篇别人的博客也无济于事。最后我想，要使用 $Hexo$ 指令，应该是将一个带有 $.exe$ 后缀的文件路径加入到 $Path$ 中，于是我使用万能的 $Everything$ 搜索了 $hexo$，于是找到了 $hexo.cmd$$Windows$ 用户应该只要将这个路径加入到系统变量中的 $Path$ 即可正常使用了。","link":"/2020/06/17/%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEhexo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"title":"暑期自训 $1$","text":"$A.\\ CF1236A$纯签 $B.\\ CF1236B$题意：有 $n$ 种礼物，每种礼物数量无限。$m$ 个可区分盒子。至少有一个盒子有礼物且每种礼物最少都要放一个。问有多少种方法。 思路：对每种礼物进行考虑，盒子有该礼物和没该礼物两种状态，这样每个盒子都能用 $0$ 和 $1$ 来表示两种状态。因为不能全空，这个时候就有 $2^m-1$ 种情况；再来考虑放礼物。不难发现，对于每个盒子来说，可以装这个礼物也可以不装，所以答案就是 $(2^m-1)^n$ 123456789101112131415161718192021222324252627282930313233343536#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i >= 1; a *= a, a %= mod; } return ans;}int main(){ cin >> n >> m; LL ans = qpow(qpow(2, m) - 1, n); cout < ans < n; int ans[maxn][maxn]; int m = n, cnt = 0; for(int i = 0; i < n; ++i) { if(i % 2 == 0) { for(int j = 0; j < n; ++j) ans[j][i] = ++cnt; } else for(int j = n - 1; j >= 0; --j) ans[j][i] = ++cnt; } for(int i = 0; i < n; ++i) for(int j = 0; j < n; ++j) printf(\"%d%c\", ans[i][j], (j == n - 1) ? '\\n' : ' '); return 0;} $G\\ CF1244A$纯签 $H\\ CF1244B$题意：两层迷宫，平行位置可以互相来往，当该位置为 $1$ 时，可以上下行走，每个格子最多走一次。问能走最多的格子的数量。 思路：当 $s[0]=’1’$ 或者 $s[n-1]=’1’$ 时，可以走完所有的格子，进而继续推导，能走多少个格子取决于的两端的 $1$ 的位置。 12345678910111213141516171819202122232425262728293031323334353637383940#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { cin >> n; cin >> s; int ans = 0; int flag = 0; vector v; for(int i = 0; i < n; ++i) if(s[i] == '1') v.push_back(i); if(!v.size()) ans = n; else { ans = max(2 * (v[0] + 1), 2 * (v.back() + 1)); ans = max(ans, 2 * (n - v[0])); ans = max(ans, 2 * (n - v.back())); } cout < ans < x >> y; d[x]++; d[y]++; if(d[x] > 2) flag = false; if(d[y] > 2) flag = false; v[x].pb(y); v[y].pb(x); } if(!flag) { puts(\"-1\"); return 0; } for(int i = 1; i","link":"/2020/06/25/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD1/"},{"title":"暑期自训2","text":"$A.\\ CF1277C$题意：给你一串括号序列，你可以选择任意一端区间进行倒置。要将其变为正则的，并且前缀中有 $k$ 个正则的，给出变换序列。 思路：先变为 $()()\\cdots()$ 形式，然后从前往后进行合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { vector ans; scanf(\"%d%d\", &n, &k); cin >> s; for(int i = 0; i < n - 1; i += 2) { if(s[i] == '(' && s[i + 1] == ')') continue; else if(s[i] == '(' && s[i + 1] != ')') { int j = i + 2; while(j < n && s[j] == '(') ++j; reverse(s + i + 1, s + j + 1); ans.pb(mk(i + 1, j)); } else if(s[i] != '(') { int j = i + 1; while(j < n && s[j] == ')') ++j; reverse(s + i, s + j + 1); ans.pb(mk(i, j)); } } int x = n / 2 - k; int i = 1, cnt = 1; while(x--) { ans.pb(mk(i, i + cnt)); i++; cnt++; } cout < ans.size() <","link":"/2020/06/29/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD2/"},{"title":"UML_Lec02_b1","text":"$UML$ 构造块$UML$ 事物 结构事物 类 接口 协作 用例 主动类 节点 构件 制品 行为事物 交互 状态机 活动 分组事物 包 注释事物 注释 关系 依赖 关联 泛化 实现 图 类图 对象图 顺序图 通信图 构件图 活动图 制品图 包图 时序图 用例图 状态图 部署图 交互概览图 对系统的体系结构建模$”4+1”$ view","link":"/2020/07/01/UML-Lec02-b1/"},{"title":"UML_Lec01_02","text":"建模的四个目的 帮助我们按照需要对系统进行可视化 允许我们详细说明系统的结构和行为 给出了一个指导我们构造系统的模板 对我们所做出的决策进行文档化 建模的四项基本原理 选择要创建什么模型 每一种模型可以在不同的精度级别上表示 最好的模型是与现实相关联的 单个模型是不充分的, 对每一个重要的系统最好用一组几乎独立的模型去处理","link":"/2020/07/01/UML-Lec01-02/"}],"tags":[{"name":"Environment configuration","slug":"Environment-configuration","link":"/tags/Environment-configuration/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"}],"categories":[{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"UML","slug":"UML","link":"/categories/UML/"}]}