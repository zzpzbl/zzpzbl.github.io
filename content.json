{"pages":[{"title":"about","text":"华东师范大学软件工程学生一名，目前大三了，感概自己一事无成。开个博客，以后把自己学习上的东西传一传吧。也算是对大学生活的一个交代了。","link":"/about/index.html"}],"posts":[{"title":"正确配置hexo环境变量","text":"最近在 $windows$ 上搭建了 $Hexo$ 博客，出师未捷身先死吧，在配置环境变量的时候总是出问题，看了好几篇别人的博客也无济于事。最后我想，要使用 $Hexo$ 指令，应该是将一个带有 $.exe$ 后缀的文件路径加入到 $Path$ 中，于是我使用万能的 $Everything$ 搜索了 $hexo$，于是找到了 $hexo.cmd$$Windows$ 用户应该只要将这个路径加入到系统变量中的 $Path$ 即可正常使用了。","link":"/2020/06/17/%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEhexo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"title":"暑期自训 $1$","text":"$A.\\ CF1236A$纯签 $B.\\ CF1236B$题意：有 $n$ 种礼物，每种礼物数量无限。$m$ 个可区分盒子。至少有一个盒子有礼物且每种礼物最少都要放一个。问有多少种方法。 思路：对每种礼物进行考虑，盒子有该礼物和没该礼物两种状态，这样每个盒子都能用 $0$ 和 $1$ 来表示两种状态。因为不能全空，这个时候就有 $2^m-1$ 种情况；再来考虑放礼物。不难发现，对于每个盒子来说，可以装这个礼物也可以不装，所以答案就是 $(2^m-1)^n$ 123456789101112131415161718192021222324252627282930313233343536#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i >= 1; a *= a, a %= mod; } return ans;}int main(){ cin >> n >> m; LL ans = qpow(qpow(2, m) - 1, n); cout < ans < n; int ans[maxn][maxn]; int m = n, cnt = 0; for(int i = 0; i < n; ++i) { if(i % 2 == 0) { for(int j = 0; j < n; ++j) ans[j][i] = ++cnt; } else for(int j = n - 1; j >= 0; --j) ans[j][i] = ++cnt; } for(int i = 0; i < n; ++i) for(int j = 0; j < n; ++j) printf(\"%d%c\", ans[i][j], (j == n - 1) ? '\\n' : ' '); return 0;} $G\\ CF1244A$纯签 $H\\ CF1244B$题意：两层迷宫，平行位置可以互相来往，当该位置为 $1$ 时，可以上下行走，每个格子最多走一次。问能走最多的格子的数量。 思路：当 $s[0]=’1’$ 或者 $s[n-1]=’1’$ 时，可以走完所有的格子，进而继续推导，能走多少个格子取决于的两端的 $1$ 的位置。 12345678910111213141516171819202122232425262728293031323334353637383940#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { cin >> n; cin >> s; int ans = 0; int flag = 0; vector v; for(int i = 0; i < n; ++i) if(s[i] == '1') v.push_back(i); if(!v.size()) ans = n; else { ans = max(2 * (v[0] + 1), 2 * (v.back() + 1)); ans = max(ans, 2 * (n - v[0])); ans = max(ans, 2 * (n - v.back())); } cout < ans < x >> y; d[x]++; d[y]++; if(d[x] > 2) flag = false; if(d[y] > 2) flag = false; v[x].pb(y); v[y].pb(x); } if(!flag) { puts(\"-1\"); return 0; } for(int i = 1; i","link":"/2020/06/25/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD1/"},{"title":"暑期自训2","text":"$A.\\ CF1277C$题意：给你一串括号序列，你可以选择任意一端区间进行倒置。要将其变为正则的，并且前缀中有 $k$ 个正则的，给出变换序列。 思路：先变为 $()()\\cdots()$ 形式，然后从前往后进行合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { vector ans; scanf(\"%d%d\", &n, &k); cin >> s; for(int i = 0; i < n - 1; i += 2) { if(s[i] == '(' && s[i + 1] == ')') continue; else if(s[i] == '(' && s[i + 1] != ')') { int j = i + 2; while(j < n && s[j] == '(') ++j; reverse(s + i + 1, s + j + 1); ans.pb(mk(i + 1, j)); } else if(s[i] != '(') { int j = i + 1; while(j < n && s[j] == ')') ++j; reverse(s + i, s + j + 1); ans.pb(mk(i, j)); } } int x = n / 2 - k; int i = 1, cnt = 1; while(x--) { ans.pb(mk(i, i + cnt)); i++; cnt++; } cout < ans.size() <","link":"/2020/06/29/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD2/"},{"title":"UML_Lec02_b1","text":"UML 构造块$UML$ 事物 结构事物 类 接口 协作 用例 主动类 节点 构件 制品 行为事物 交互 状态机 活动 分组事物 包 注释事物 注释 关系 依赖 关联 泛化 实现 图 类图 对象图 顺序图 通信图 构件图 活动图 制品图 包图 时序图 用例图 状态图 部署图 交互概览图 对系统的体系结构建模$”4+1”$ view","link":"/2020/07/01/UML-Lec02-b1/"},{"title":"UML_Lec01_02","text":"建模的四个目的 帮助我们按照需要对系统进行可视化 允许我们详细说明系统的结构和行为 给出了一个指导我们构造系统的模板 对我们所做出的决策进行文档化 建模的四项基本原理 选择要创建什么模型 每一种模型可以在不同的精度级别上表示 最好的模型是与现实相关联的 单个模型是不充分的, 对每一个重要的系统最好用一组几乎独立的模型去处理","link":"/2020/07/01/UML-Lec01-02/"},{"title":"UML_Lec02_b2","text":"$UML$ 和面向对象 $UML$ 不是面向对象的技术 $UML$ 的符号、语义可以用来描述面向对象的概念 重载和重写 重写，也叫覆盖，是指在子类中重新定义父类的函数 重载指在同一个类中出现多个同名的方法的现象，重载发生在同一个类中 多态和多态性 多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承） 序列数据类型有多种形态：字符串，列表，元组 动物有多种形态：人，🐕，🐖 多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为。 多态性的好处 增加了程序的灵活性 增加了程序的可扩展性","link":"/2020/07/02/UML-Lec02-b2/"},{"title":"UML-Lec03","text":"四种关系 关联关系 实线+无箭头 依赖关系 箭头指向被依赖的一方 虚线+叉箭头 继承关系（泛化关系） 实线+空心箭头 实现关系 虚线+空心箭头 参与者与参与者 泛化关系 参与者与用例 关联关系 用例与用例 泛化关系 包含关系：基用例指向子用例 扩展关系：子用例指向基用例","link":"/2020/09/05/UML-Lec03/"},{"title":"UML-Lec05","text":"类类的定义：具有相同属性、相同行为的一组对象的描述符，是真实世界事物的抽象 类的表示–责职 是类的合约或责任 一个良好定义的类应该有清晰的职责 一个类应只承担一种职责 类的职责划分的好坏，决定了设计方案的内聚性及耦合性 关系 依赖关系：说明一个事物使用另一个事物的信息和服务 泛化关系：子类和父类之间 关联关系 关联关系的修饰 名称及其方向 角色：在关联的每一端，表明和相连的类在该关联关系中的作用 多重性聚合/组合 聚合：整体有管理部分的特有的职责，空菱形 组合：整体有部分的生命，实菱形","link":"/2020/09/05/UML-Lec05/"},{"title":"UML-Lec06","text":"公共机制 修饰 注释 可见性、角色、多重性 扩充机制 构造型 标记值 约束 规格说明 公用划分 扩充机制构造型类似于已有的 UML 建模元素又是对特定问题领域具有特殊含义的新的建模元素 标记值在建模过程中，出于某种原因需要增加一个新的构成以表达建模元素的某种特性，用花括号括起来 约束为对应的建模元素规定了一个条件，用花括号括起来 类的扩充机制 控制类 边界类 实体类 他们都是类的构造型","link":"/2020/09/05/UML-Lec06/"},{"title":"嵌套函数和闭包","text":"嵌套函数和闭包在 JS 中，可以在一个函数中嵌套另一个函数，内部函数对外部函数是私有的。它自身也形成了一个闭包，这意味着它自身可以拥有独立的环境与变量表达式。 一个嵌套（内部）函数可以“继承”容器（外部）函数的参数和变量，也就是说，内部函数包含外部函数的作用域。 内部函数只能在外部函数中访问 内部函数形成了一个闭包：他可以访问外部函数的参数和变量，但外部函数却不能使用它的变量和参数。 123456789function addSquares(a, b) { function square(x) { return x * x; } return square(a) + square(b);}a = addSquares(2, 3); // returns 13b = addSquares(3, 4); // returns 25c = addSquares(4, 5); // returns 41 由于内部函数形成了闭包，因此你可以调用外部函数并为外部函数和内部函数指定参数 1234567891011121314function outside(x) { function inside(y) { return x + y; } return inside;}fn_inside = outside(3); // 可以这样想：给一个函数，使它的值加3，fn_inside 成为了一个函数console.log(fn_inside);result = fn_inside(5); // returns 8result1 = outside(3)(5); // returns 8console.log(result); 保存变量一个闭包必须保存它可见作用域中所有参数和变量。因为每一次调用传入的参数都可能不同，每一次对外部函数的调用实际上重新创建了一遍这个闭包，只有当返回的 inside 没有再次被引用时，内存才会释放。 多层嵌套函数函数可以被多层嵌套，因此，闭包可以包含多个作用域；他们递归式的包含了所有包含它的函数作用域，这个称之为作用域链。 1234567891011121314function A(x) { function B(y) { console.log(111); function C(z) { console.log(x + y + z); } C(3); } console.log(333); B(2); console.log(222);}A(1); // logs 6 (1 + 2 + 3) 输出结果： 12343331116222 命名冲突当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。 123456789function outside() { var x = 5; function inside(x) { return x * 2; } return inside;}outside()(10); // returns 20 instead of 10 闭包闭包是 JavaScript 最强大的特性之一。当内部函数的生存周期大于外部函数时，外部函数中的定义的变量和函数的生存周期将比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。 1234567891011var pet = function(name) { //外部函数定义了一个变量\"name\" var getName = function() { //内部函数可以访问 外部函数定义的\"name\" return name; } //返回这个内部函数，从而将其暴露在外部函数作用域 return getName; };myPet = pet(\"Vivie\"); myPet(); // 返回结果 \"Vivie\" 使用 arguments 对象函数的实际参数会被保存在一个类似数组的 arguments 对象中。 使用 arguments 对象，你可以处理比声明的更多的参数来调用函数。这在你事先不知道会需要将多少参数传递给函数时十分有用。 例如下面这个链接字符串的函数 1234567891011function myConcat(separator) { var result = ''; // 把值初始化成一个字符串，这样就可以用来保存字符串了！！ var i; // iterate through arguments for (i = 1; i < arguments.length; i++) { result += arguments[i] + separator; } return result;}// returns \"red, orange, blue, \"myConcat(\", \", \"red\", \"orange\", \"blue\"); 函数参数默认参数在 JavaScript 中，函数参数的默认值是 undefined。 剩余参数剩余参数语法允许将不确定的参数表示为数组 123456function multiply(multiplier, ...theArgs) { return theArgs.map(x => multiplier * x);}var arr = multiply(2, 1, 2, 3);console.log(arr); // [2, 4, 6]","link":"/2020/09/15/%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/"},{"title":"牛客多校02","text":"$F\\ Fake\\ Maxpooling(二维单调队列)$题意：给你一个 $nm$ 的数组，数组中的元素为 $a_{i,j}=lcm(i,j)$，再给你一个数字 $k$，求出子矩阵大小为 $kk$ 的最大值的和。 思路：这里介绍一下单调队列。单调队列，顾名思义，就是一种具有单调性的队列，一种递增，另一种递减。用单调队列来解决问题，一般都是需要得到当前区间的最小值或者最大值。 我们先考虑一维的情况，得到区间长度为 $k$ 的最大值。 举个例子：有 $7,6,8,12,9,10,3$ 七个数字，现在让你找出范围 $(i-4,i]$ 的最小值。接下来是模拟过程： 初始化为 ${0}$。 $i=1\\rightarrow{7}$$i=2\\rightarrow{6}$$i=3\\rightarrow{6,8}$$i=4\\rightarrow{6,8,12}$$i=5\\rightarrow{6,8,9}$$i=6$ 此时队列中元素 $6$ 不在范围 $(2,6]$ 中，故将 $6$ 弹出 $\\rightarrow{8,9,10}$$i=7\\rightarrow{3}$ 我们来看一道例题：洛谷 $p1866$ 题目描述：有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。我们直接套模板解决这道题吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include #include #include #define pii pairusing namespace std;int n, k;int a[1000007];deque que_max;deque que_min;vector ans_max, ans_min;int main(){ scanf(\"%d%d\", &n, &k); for(int i = 1; i","link":"/2020/07/21/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A102/"},{"title":"牛客多校03","text":"$G\\ Operating\\ on\\ a\\ Graph$题意：给定一个图，$q$ 次询问，每次询问为一个颜色 $o$，若该图上存在颜色为 $o$ 的部分，则将与该部分相邻的点涂成颜色 $o$，问最后每个点是什么颜色。 思路：首先容易想到，这个题应该可以用并查集来维护颜色信息。很直观的做法是我们把该部分相连的每一个点都更改颜色，但这样很显然会超时。我们用 $vector[i]$ 来维护与 $i$ 相邻的点，每次询问时，遍历所有与该部分相邻的点（如果属于就直接跳过），将所有属于该点祖先的边内所有点点放入颜色 $o$ 中。合并的时候要用到启发式合并，将小集合合并到大集合当中去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define ArrayDebug(a, l, r) for(int i = l; i","link":"/2020/07/21/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A103/"}],"tags":[{"name":"Environment configuration","slug":"Environment-configuration","link":"/tags/Environment-configuration/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"JS","slug":"JS","link":"/tags/JS/"}],"categories":[{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"UML","slug":"UML","link":"/categories/UML/"},{"name":"Web","slug":"Web","link":"/categories/Web/"}]}