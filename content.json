{"pages":[{"title":"about","text":"华东师范大学软件工程学生一名，目前大三了，感概自己一事无成。开个博客，以后把自己学习上的东西传一传吧。也算是对大学生活的一个交代了。","link":"/about/index.html"}],"posts":[{"title":"UML_Lec01_02","text":"建模的四个目的 帮助我们按照需要对系统进行可视化 允许我们详细说明系统的结构和行为 给出了一个指导我们构造系统的模板 对我们所做出的决策进行文档化 建模的四项基本原理 选择要创建什么模型 每一种模型可以在不同的精度级别上表示 最好的模型是与现实相关联的 单个模型是不充分的, 对每一个重要的系统最好用一组几乎独立的模型去处理","link":"/2020/07/01/UML-Lec01-02/"},{"title":"MapReduce","text":"","link":"/2021/01/28/MapReduce/"},{"title":"UML_Lec02_b1","text":"UML 构造块$UML$ 事物 结构事物 类 接口 协作 用例 主动类 节点 构件 制品 行为事物 交互 状态机 活动 分组事物 包 注释事物 注释 关系 依赖 关联 泛化 实现 图 类图 对象图 顺序图 通信图 构件图 活动图 制品图 包图 时序图 用例图 状态图 部署图 交互概览图 对系统的体系结构建模$”4+1”$ view","link":"/2020/07/01/UML-Lec02-b1/"},{"title":"Redis数据类型：string","text":"写在前面寒假在家无聊，就想着看看 Redis5.0 的源码，刚好在知乎也看见一个写的不错的笔记，就顺着它的学习路线看代码了 Redis 是什么？Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、分布式、可持久性的键值对存储数据库（wiki 百科）。 Redis 支持哪些数据类型？ 字符串 字符串列表 无序不重复的字符串集合 有序不重复的字符串集合 键、值都为字符串的哈希表 持久化Redis 一般将全部的数据都存储在内存中，目前通过两种方法实现持久化： 快照，一种半持久内用模式。不时地将数据集以异步的方式从内存以 RDB 格式写入硬盘。 1.1 版本开始使用更安全的 AOF 格式替代，一种只能追加的日志类型。将数据集修改操作记录起来。Redis 能够在后台对只可追加的记录作修改来避免无限增长的日志 同步Redis 支持主从同步。数据可以从主服务器向任意数量的服务器上同步，从服务器可以使关联其他从服务器的主服务器，这使得 Redis 可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。（讲道理这些我现在也不是很懂。。。） 性能当数据依赖不再需要，Redis这种基于内存的性质，与在执行一个事务时将每个变化都写入硬盘的数据库系统相比就显得执行效率非常高。写与读操作速度没有明显差别 Redis 中的 string —— sdshdr数据类型Redis5.0 中定义了五种 string 类型： sdshdr5 sdshdr8 sdshdr16 sdshdr32 sdshdr64 没错，后面的数字后缀代表了能存储的字符串的最大长度。我们先来看后面四种，他们都具有相同的结构： 123456struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; // 已使用长度 uint8_t alloc; // 总的大小 unsigned char flags; // 第三位记录类型，高五位无用处 char buf[]; // 实际字符缓存}; 所以，sdshdr 类型的结构图如下： 图源： 也就是说，sdshdr 在内存中的格式为一个 Header 字段加上一段连续内存。sds 就是实际字符串的第一个字节。 由于只有 5 种类型，所以用一个 unsigned char 类型足够描述该种 sdshdr 类型，Redis 中定义了几种 type: 1234567#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7#define SDS_TYPE_BITS 3 显然，通过 flags 字段与 SDS_TYPE_MASK 做位与运算，我们可以得到其类型，而由于结构体使用的是非对齐类型（__attribute__ ((__packed__))），所以，我们直接通过访问 s[-1] 即可获得其头部信息。（讲道理我看到这个也傻了，这不是 runtime error 吗？但是转头一想，里面的数字不过是个偏移量罢了，只要你访问的那段内存是有效的，又怎么会产生段错误呢？） 现在我们来看看 sdshdr5 吧，他的结构如下： 12345struct __attribute__ ((__packed__)) sdshdr5{ unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[];}; 这样看上去，好像 sdshdr5 就是为了那些较短的字符串（不超过 32 个字节）准备的吧，像是一种静态的类型。对此，Redis 的作者也给出了建议： Don't use TYPE 5 if strings are going to be reallocated, since it sucks not having a free space left field. （谁会给 32 个字节的东西重新分配大小呢？） 通用底层操作在源码中，我们可以看到许多的宏定义： 1#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) 讲道理 struct sdshdr##T 是啥意思我真不明白，也没找到，我们结合使用了这个宏定义的函数来看看： 12345678910111213141516static inline size_t sdslen(const sds s) { unsigned char flags = s[-1]; switch(flags&SDS_TYPE_MASK) { case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)->len; case SDS_TYPE_16: return SDS_HDR(16,s)->len; case SDS_TYPE_32: return SDS_HDR(32,s)->len; case SDS_TYPE_64: return SDS_HDR(64,s)->len; } return 0;} 从名字不难得出，这就是返回 string 长度的，也就是 Header 中的 len 字段，注意传递进来的 sds 就是 char * 。 很明显，我们需要通过传递进来的 sds 数据得到对应的 Header 指针，这样我们才能访问 len 字段，那上面的式子就好理解了啊！##T 应该是被替换成了相应的数字，很巧妙的设计！因为结构体中的 char buf[] 是不占内存的，这样我们就直接访问到了 Header 的第一个字节，后面代码中很多地方都巧妙地利用了这一点。 1#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); 这一句相比也很明白了，定义了一个全局变量 sh，他能指向对应字符串的 Header 字段的第一个字节。 接下来就是一些字面意思的函数了： 1static inline size_t sdsavail(const sds s) 计算还有多少可用空间 1static inline void sdssetlen(sds s, size_t newlen) 设置新长度 1static inline void sdsinclen(sds s, size_t inc) 增加长度 1static inline size_t sdsalloc(const sds s) 得到总空间 1static inline void sdssetalloc(sds s, size_t newlen) 重置总空间 各种操作函数123static inline char sdsReqType(size_t string_size);static inline int sdsHdrSzie(char type);static inline size_t sdsTypeMaxSize(char type) 这是位与 src/sds.c 中的两个静态函数，分别用于返回一个特定 HeaderType的头部结构体长度、根据一个 string_size 的长度，返回合适的 HeaderType、以及根据 type 返回最大容量。 1sds _sdsnewlen(const void *init, size_t initlen, int trymalloc); 这是根据给定的 init 指针和 initlen 长度 来创建一个 sds 的函数，他的实现还是比较复杂的，具体描述如下： 我们根据给定的长度返回一个 HeaderType，比如：5，8，16，32 或者 64，然后对一个 void * 类型的变量进行初始化，长度为 initlen+hdrlen+1，加一是有讲究的，因为在 Redis 中 sds 总是以 '\\0' 作为结尾的，所以需要多分配一个字节的内存，哪有的小伙伴就有疑问了，要是数据中出现了 '\\0' 怎么办？这点完全不用担心，因为我们有 len 字段啊。之后我们会初始化 Header 中的各个字段，并将 init 中的内容拷贝到 sds 的缓冲区，以 '\\0' 结尾。 12345678910111213141516171819202122sds sdsnewlen(const void *init, size_t initlen) { return _sdsnewlen(init, initlen, 0);}sds sdstrynewlen(const void *init, size_t initlen) { return _sdsnewlen(init, initlen, 1);}/* Create an empty (zero length) sds string. Even in this case the string * always has an implicit null term. */sds sdsempty(void) { return sdsnewlen(\"\",0);}/* Create a new sds string starting from a null terminated C string. */sds sdsnew(const char *init) { size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);}/* Duplicate an sds string. */sds sdsdup(const sds s) { return sdsnewlen(s, sdslen(s));} 这些函数都很简单，对着上面看就 ok 了，但是有关内存分配我其实并没有讲，这一块确实比较大，我打算以后单独拎出来。 接下来我们看以个比较有意思的函数 1sds sdsMakeRoomFor(sds s, size_t addlen); 这个接口用于给一个给定的字符串扩容，可以确保用户在调用这个接口之后，可以向缓存之中续写 addlen 个字节的内容，但是这个操作不会改变已经使用的缓存的大小，也就是不会改变 sdslen 调用的结果。这个函数有点儿复杂，我就不讲码德直接上代码了。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh, *newsh; // 计算剩余空间 size_t avail = sdsavail(s); size_t len, newlen; char type, oldtype = s[-1] & SDS_TYPE_MASK; int hdrlen; size_t usable; /* 如果剩余空间足够的话，就原封不动返回 */ if (avail >= addlen) return s; // 参数字符串长度 len = sdslen(s); // 获取 Header 指针 sh = (char*)s-sdsHdrSize(oldtype); newlen = (len+addlen); // 这里的目的是减少多次扩容带来开销，索性一次给多点，1024 * 1024，也就是 1MB if (newlen < SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; // 获得新类型 type = sdsReqType(newlen); // 提示好好看，就是别用 sdshdr5 /* Don't use type 5: the user is appending to the string and type 5 is * not able to remember empty space, so sdsMakeRoomFor() must be called * at every appending operation. */ if (type == SDS_TYPE_5) type = SDS_TYPE_8; hdrlen = sdsHdrSize(type); // 没有引发升级 if (oldtype==type) { newsh = s_realloc_usable(sh, hdrlen+newlen+1, &usable); if (newsh == NULL) return NULL; s = (char*)newsh+hdrlen; } else { // 升级了的话会构造一个新的 sds /* Since the header size changes, need to move the string forward, * and can't use realloc */ newsh = s_malloc_usable(hdrlen+newlen+1, &usable); if (newsh == NULL) return NULL; memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh+hdrlen; s[-1] = type; sdssetlen(s, len); } usable = usable-hdrlen-1; if (usable > sdsTypeMaxSize(type)) usable = sdsTypeMaxSize(type); sdssetalloc(s, usable); return s;} 尤其是最后一点，升级将会导致分配一个新的 sds，然后返回新的指针，这也就意味着调用者无法保证作为参数传入的 sds 指针在调用结束后是否有效，对此，作者给出了建议： Don't call sdsMakeRoomFor() when obviously not needed. 剩下的就是处理内容的函数了，这些我就自个儿慢慢看了（或者咕掉），都不是很复杂，类似于 C 中的一些处理函数，只不过要注意处理 Header 字段。","link":"/2021/02/09/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Astring/"},{"title":"UML-Lec03","text":"四种关系 关联关系 实线+无箭头 依赖关系 箭头指向被依赖的一方 虚线+叉箭头 继承关系（泛化关系） 实线+空心箭头 实现关系 虚线+空心箭头 参与者与参与者 泛化关系 参与者与用例 关联关系 用例与用例 泛化关系 包含关系：基用例指向子用例 扩展关系：子用例指向基用例","link":"/2020/09/05/UML-Lec03/"},{"title":"UML_Lec02_b2","text":"$UML$ 和面向对象 $UML$ 不是面向对象的技术 $UML$ 的符号、语义可以用来描述面向对象的概念 重载和重写 重写，也叫覆盖，是指在子类中重新定义父类的函数 重载指在同一个类中出现多个同名的方法的现象，重载发生在同一个类中 多态和多态性 多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承） 序列数据类型有多种形态：字符串，列表，元组 动物有多种形态：人，🐕，🐖 多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为。 多态性的好处 增加了程序的灵活性 增加了程序的可扩展性","link":"/2020/07/02/UML-Lec02-b2/"},{"title":"UML-Lec06","text":"公共机制 修饰 注释 可见性、角色、多重性 扩充机制 构造型 标记值 约束 规格说明 公用划分 扩充机制构造型类似于已有的 UML 建模元素又是对特定问题领域具有特殊含义的新的建模元素 标记值在建模过程中， 出于某种原因需要增加一个新的构成以表达建模元素的某种特性，用花括号括起来 约束为对应的建模元素规定了一个条件，用花括号括起来 类的扩充机制 控制类 边界类 实体类 他们都是类的构造型","link":"/2020/09/05/UML-Lec06/"},{"title":"UML-Lec05","text":"类类的定义：具有相同属性、相同行为的一组对象的描述符，是真实世界事物的抽象 类的表示–责职 是类的合约或责任 一个良好定义的类应该有清晰的职责 一个类应只承担一种职责 类的职责划分的好坏，决定了设计方案的内聚性及耦合性 关系 依赖关系：说明一个事物使用另一个事物的信息和服务 泛化关系：子类和父类之间 关联关系 关联关系的修饰 名称及其方向 角色：在关联的每一端，表明和相连的类在该关联关系中的作用 多重性聚合/组合 聚合：整体有管理部分的特有的职责，空菱形 组合：整体有部分的生命，实菱形","link":"/2020/09/05/UML-Lec05/"},{"title":"electron-ipcMain.md","text":"ipcMain从主进程到渲染进程的异步通信。当在主进程中使用时，它处理从渲染进程（网页）发送出来的异步和同步信息。从渲染器进程发送的消息将发送到该模块。 发送消息也可以从主进程向渲染进程发送消息。 发送消息，事件名称为 channel 回复同步信息时，需要设置 event.returnValue 可以使用 event.sender.send() 将异步消息发回发送者。 例子： 1234567891011// 主进程const { ipcMain } = require('electron')ipcMain.on('asynchronous-message', (event, arg) => { console.log(arg) event.reply('asynchronous-reply', 'pong')})ipcMain.on('synchronous-message', (event, arg) => { console.log(arg) event.returnValue = 'pong'}) 12345678// 渲染进程const { ipaRenderer } = require('electron')console.log(ipcRenderer.sendSync('synchronous-message', 'ping'))ipcRenderer.on('asynchronous-reply', (event, arg) => { console.log(arg)})ipcRenderer.send('asynchronous-message', 'ping') 方法ipcMain.on(channel, listener) channel String listener Function event IpcMainEvent ...args any[] 监听 channel，当接收到新的消息时 listener 会以 listener(event, args) 的形式被调用。 ipcMain.once(channel, listener) channel String listener Function event IpcMainEvent ...args any[] 为事件添加一次监听器功能，仅在下次将消息发送到通道时才调用此侦听器，然后将其删除。 ipcMain.removeListener(channel, listener) channel String listener Function ...args any[] 从监听器数组中移除监听 channel 的指定 listener 。 ipcMain.removeAllListeners([channel]) channel String (optional) 删除所有监听者，或指定的 channel 的所有监听者。 ipcMain.handle(channel, listener) channel String listener Function event IpcMainInvokeEvent ...args any[] 为可调用的 IPC 添加处理程序。每当渲染器程序调用 ipcRenderer.invoke(channel, ...args) 都会调用这个处理程序。 如果 listener 返回一个 Promise ，则 Promise 的最终结果将作为对远程调用者的答复而返回。否则，listener 的返回值将用作回复的值。 1234567891011// Main processipcMain.handle('my-invokable-ipc', async (event, ...args) => { const result = await somePromise(...args) return result})// Renderer processasync () => { const result = await ipcRenderer.invoke('my-invokable-ipc', arg1, arg2) // ...} 作为第一个参数传递给处理程序的事件与传递给常规事件侦听器的事件相同，它包含有关哪些 WebContents 是调用请求源的信息。 ipcMain.handleOnce(channel, listener) channel String listener Function event IpcMainInvokeEvent ...args any[] 处理单个可调用的 IPC 消息，然后删除侦听器 ipcMain.removeHandler(channel) channel String 为 channel 删除所有处理程序。 ipcMainEvent Object extends Event frameID Integer - 发送该消息的渲染进程框架的 ID returnValue any - 将其设置为要在同步消息中返回的值 sender WebContents - 返回发送消息的 WebContents ports MessagePortMain[] - 随着消息一起传送的 MessagePort 列表 reply Function - 将 IPC 消息发送到渲染器框架的函数，该渲染器框架发送当前正在处理的原始消息，你应该使用 reply 方法回复发送的消息，以确保回复将转到正确的进程和框架。 channel String ...args any[] ipcRendererEvent 对象继承 Event frameID Integer - 发送该消息的渲染进程框架的 ID WebContents - 返回发送消息的 WebContents","link":"/2020/09/17/electron-ipcMain-md/"},{"title":"嵌套函数和闭包","text":"在 JS 中，可以在一个函数中嵌套另一个函数，内部函数对外部函数是私有的。它自身也形成了一个闭包，这意味着它自身可以拥有独立的环境与变量表达式。 一个嵌套（内部）函数可以“继承”容器（外部）函数的参数和变量，也就是说，内部函数包含外部函数的作用域。 内部函数只能在外部函数中访问 内部函数形成了一个闭包：他可以访问外部函数的参数和变量，但外部函数却不能使用它的变量和参数。 123456789function addSquares(a, b) { function square(x) { return x * x; } return square(a) + square(b);}a = addSquares(2, 3); // returns 13b = addSquares(3, 4); // returns 25c = addSquares(4, 5); // returns 41 由于内部函数形成了闭包，因此你可以调用外部函数并为外部函数和内部函数指定参数 1234567891011121314function outside(x) { function inside(y) { return x + y; } return inside;}fn_inside = outside(3); // 可以这样想：给一个函数，使它的值加3，fn_inside 成为了一个函数console.log(fn_inside);result = fn_inside(5); // returns 8result1 = outside(3)(5); // returns 8console.log(result); 保存变量一个闭包必须保存它可见作用域中所有参数和变量。因为每一次调用传入的参数都可能不同，每一次对外部函数的调用实际上重新创建了一遍这个闭包，只有当返回的 inside 没有再次被引用时，内存才会释放。 多层嵌套函数函数可以被多层嵌套，因此，闭包可以包含多个作用域；他们递归式的包含了所有包含它的函数作用域，这个称之为作用域链。 1234567891011121314function A(x) { function B(y) { console.log(111); function C(z) { console.log(x + y + z); } C(3); } console.log(333); B(2); console.log(222);}A(1); // logs 6 (1 + 2 + 3) 输出结果： 12343331116222 命名冲突当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。 123456789function outside() { var x = 5; function inside(x) { return x * 2; } return inside;}outside()(10); // returns 20 instead of 10 闭包闭包是 JavaScript 最强大的特性之一。当内部函数的生存周期大于外部函数时，外部函数中的定义的变量和函数的生存周期将比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。 1234567891011var pet = function(name) { //外部函数定义了一个变量\"name\" var getName = function() { //内部函数可以访问 外部函数定义的\"name\" return name; } //返回这个内部函数，从而将其暴露在外部函数作用域 return getName; };myPet = pet(\"Vivie\"); myPet(); // 返回结果 \"Vivie\" 使用 arguments 对象函数的实际参数会被保存在一个类似数组的 arguments 对象中。 使用 arguments 对象，你可以处理比声明的更多的参数来调用函数。这在你事先不知道会需要将多少参数传递给函数时十分有用。 例如下面这个链接字符串的函数 1234567891011function myConcat(separator) { var result = ''; // 把值初始化成一个字符串，这样就可以用来保存字符串了！！ var i; // iterate through arguments for (i = 1; i < arguments.length; i++) { result += arguments[i] + separator; } return result;}// returns \"red, orange, blue, \"myConcat(\", \", \"red\", \"orange\", \"blue\"); 函数参数默认参数在 JavaScript 中，函数参数的默认值是 undefined。 剩余参数剩余参数语法允许将不确定的参数表示为数组 123456function multiply(multiplier, ...theArgs) { return theArgs.map(x => multiplier * x);}var arr = multiply(2, 1, 2, 3);console.log(arr); // [2, 4, 6]","link":"/2020/09/15/%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/"},{"title":"正则表达式匹配","text":"题意：给你一个字符串 s 和一个字符规律 p，请你实现一个支持 '.' 和 '*' 的正则表达式匹配。12'.' 匹配任意单个字符'*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。 样例： 12345输入：s = \"aab\"p = \"c*a*b\"输出 ：true解释 ： 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 思路：很明显这道题属于动归吧？状态其实很好表示：dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符的匹配情况，转移方程的关键在于 s[i] 和 p[j]。尤其要注意 . 和 * 字符。 当 s[i] == p[j] || p[j] == '.' 时，dp[i][j] = dp[i-1][j-1； 当 p[j] == '* 时，情况就显得比较复杂了: 当 s[i] != p[j-1] && p[j-1] != '. 时，意味着 s 的前 i 个字符与 p 的前 j 和前 j-1 个字符都是不能匹配的（因为末尾不相等），所以 dp[i][j] = dp[i][j-2]； 否则，就把最后的 p[j-1],p[j] 来进行分类讨论，由于 * 代表重复 $0$ 到多次，所以这时候就很明显了，要么 $0$，次，要么多次；$0$ 次的时候：dp[i][j] = dp[i][j-2]，多次的时候：dp[i][j] = dp[i-1][j]。这二者是或的关系。 注意： 空串的情况。 初始化 dp[0][0] = 1。 解决空串比较好的一个方法是在 s 和 p 前都加一个 \"\"。 代码：1234567891011121314151617181920class Solution {public: bool isMatch(string s, string p) { s = \" \"+s; p = \" \"+p; int n = s.size(), m = p.size(); int dp[n+1][m+1]; memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for(int i = 1; i","link":"/2020/10/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"title":"暑期自训 $1$","text":"$A.\\ CF1236A$纯签 $B.\\ CF1236B$题意：有 $n$ 种礼物，每种礼物数量无限。$m$ 个可区分盒子。至少有一个盒子有礼物且每种礼物最少都要放一个。问有多少种方法。 思路：对每种礼物进行考虑，盒子有该礼物和没该礼物两种状态，这样每个盒子都能用 $0$ 和 $1$ 来表示两种状态。因为不能全空，这个时候就有 $2^m-1$ 种情况；再来考虑放礼物。不难发现，对于每个盒子来说，可以装这个礼物也可以不装，所以答案就是 $(2^m-1)^n$ 123456789101112131415161718192021222324252627282930313233343536#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i >= 1; a *= a, a %= mod; } return ans;}int main(){ cin >> n >> m; LL ans = qpow(qpow(2, m) - 1, n); cout < ans < n; int ans[maxn][maxn]; int m = n, cnt = 0; for(int i = 0; i < n; ++i) { if(i % 2 == 0) { for(int j = 0; j < n; ++j) ans[j][i] = ++cnt; } else for(int j = n - 1; j >= 0; --j) ans[j][i] = ++cnt; } for(int i = 0; i < n; ++i) for(int j = 0; j < n; ++j) printf(\"%d%c\", ans[i][j], (j == n - 1) ? '\\n' : ' '); return 0;} $G\\ CF1244A$纯签 $H\\ CF1244B$题意：两层迷宫，平行位置可以互相来往，当该位置为 $1$ 时，可以上下行走，每个格子最多走一次。问能走最多的格子的数量。 思路：当 $s[0]=’1’$ 或者 $s[n-1]=’1’$ 时，可以走完所有的格子，进而继续推导，能走多少个格子取决于的两端的 $1$ 的位置。 12345678910111213141516171819202122232425262728293031323334353637383940#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { cin >> n; cin >> s; int ans = 0; int flag = 0; vector v; for(int i = 0; i < n; ++i) if(s[i] == '1') v.push_back(i); if(!v.size()) ans = n; else { ans = max(2 * (v[0] + 1), 2 * (v.back() + 1)); ans = max(ans, 2 * (n - v[0])); ans = max(ans, 2 * (n - v.back())); } cout < ans < x >> y; d[x]++; d[y]++; if(d[x] > 2) flag = false; if(d[y] > 2) flag = false; v[x].pb(y); v[y].pb(x); } if(!flag) { puts(\"-1\"); return 0; } for(int i = 1; i","link":"/2020/06/25/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD1/"},{"title":"暑期自训2","text":"$A.\\ CF1277C$题意：给你一串括号序列，你可以选择任意一端区间进行倒置。要将其变为正则的，并且前缀中有 $k$ 个正则的，给出变换序列。 思路：先变为 $()()\\cdots()$ 形式，然后从前往后进行合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { vector ans; scanf(\"%d%d\", &n, &k); cin >> s; for(int i = 0; i < n - 1; i += 2) { if(s[i] == '(' && s[i + 1] == ')') continue; else if(s[i] == '(' && s[i + 1] != ')') { int j = i + 2; while(j < n && s[j] == '(') ++j; reverse(s + i + 1, s + j + 1); ans.pb(mk(i + 1, j)); } else if(s[i] != '(') { int j = i + 1; while(j < n && s[j] == ')') ++j; reverse(s + i, s + j + 1); ans.pb(mk(i, j)); } } int x = n / 2 - k; int i = 1, cnt = 1; while(x--) { ans.pb(mk(i, i + cnt)); i++; cnt++; } cout < ans.size() <","link":"/2020/06/29/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD2/"},{"title":"正确配置hexo环境变量","text":"最近在 $windows$ 上搭建了 $Hexo$ 博客，出师未捷身先死吧，在配置环境变量的时候总是出问题，看了好几篇别人的博客也无济于事。最后我想，要使用 $Hexo$ 指令，应该是将一个带有 $.exe$ 后缀的文件路径加入到 $Path$ 中，于是我使用万能的 $Everything$ 搜索了 $hexo$，于是找到了 $hexo.cmd$$Windows$ 用户应该只要将这个路径加入到系统变量中的 $Path$ 即可正常使用了。","link":"/2020/06/17/%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEhexo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"title":"牛客多校02","text":"$F\\ Fake\\ Maxpooling(二维单调队列)$题意：给你一个 $nm$ 的数组，数组中的元素为 $a_{i,j}=lcm(i,j)$，再给你一个数字 $k$，求出子矩阵大小为 $kk$ 的最大值的和。 思路：这里介绍一下单调队列。单调队列，顾名思义，就是一种具有单调性的队列，一种递增，另一种递减。用单调队列来解决问题，一般都是需要得到当前区间的最小值或者最大值。 我们先考虑一维的情况，得到区间长度为 $k$ 的最大值。 举个例子：有 $7,6,8,12,9,10,3$ 七个数字，现在让你找出范围 $(i-4,i]$ 的最小值。接下来是模拟过程： 初始化为 ${0}$。 $i=1\\rightarrow{7}$$i=2\\rightarrow{6}$$i=3\\rightarrow{6,8}$$i=4\\rightarrow{6,8,12}$$i=5\\rightarrow{6,8,9}$$i=6$ 此时队列中元素 $6$ 不在范围 $(2,6]$ 中，故将 $6$ 弹出 $\\rightarrow{8,9,10}$$i=7\\rightarrow{3}$ 我们来看一道例题：洛谷 $p1866$ 题目描述：有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。我们直接套模板解决这道题吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include #include #include #define pii pairusing namespace std;int n, k;int a[1000007];deque que_max;deque que_min;vector ans_max, ans_min;int main(){ scanf(\"%d%d\", &n, &k); for(int i = 1; i","link":"/2020/07/21/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A102/"},{"title":"牛客多校03","text":"$G\\ Operating\\ on\\ a\\ Graph$题意：给定一个图，$q$ 次询问，每次询问为一个颜色 $o$，若该图上存在颜色为 $o$ 的部分，则将与该部分相邻的点涂成颜色 $o$，问最后每个点是什么颜色。 思路：首先容易想到，这个题应该可以用并查集来维护颜色信息。很直观的做法是我们把该部分相连的每一个点都更改颜色，但这样很显然会超时。我们用 $vector[i]$ 来维护与 $i$ 相邻的点，每次询问时，遍历所有与该部分相邻的点（如果属于就直接跳过），将所有属于该点祖先的边内所有点点放入颜色 $o$ 中。合并的时候要用到启发式合并，将小集合合并到大集合当中去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define ArrayDebug(a, l, r) for(int i = l; i","link":"/2020/07/21/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A103/"}],"tags":[{"name":"MapReduce","slug":"MapReduce","link":"/tags/MapReduce/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Dynamic programming","slug":"Dynamic-programming","link":"/tags/Dynamic-programming/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Environment configuration","slug":"Environment-configuration","link":"/tags/Environment-configuration/"}],"categories":[{"name":"UML","slug":"UML","link":"/categories/UML/"},{"name":"Distributed Systems","slug":"Distributed-Systems","link":"/categories/Distributed-Systems/"},{"name":"artical","slug":"artical","link":"/categories/artical/"},{"name":"Client","slug":"Client","link":"/categories/Client/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"}]}