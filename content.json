{"pages":[{"title":"about","text":"åä¸œå¸ˆèŒƒå¤§å­¦è½¯ä»¶å·¥ç¨‹å­¦ç”Ÿä¸€åï¼Œç›®å‰å¤§ä¸‰äº†ï¼Œæ„Ÿæ¦‚è‡ªå·±ä¸€äº‹æ— æˆã€‚å¼€ä¸ªåšå®¢ï¼Œä»¥åæŠŠè‡ªå·±å­¦ä¹ ä¸Šçš„ä¸œè¥¿ä¼ ä¸€ä¼ å§ã€‚ä¹Ÿç®—æ˜¯å¯¹å¤§å­¦ç”Ÿæ´»çš„ä¸€ä¸ªäº¤ä»£äº†ã€‚","link":"/about/index.html"}],"posts":[{"title":"UML_Lec01_02","text":"å»ºæ¨¡çš„å››ä¸ªç›®çš„ å¸®åŠ©æˆ‘ä»¬æŒ‰ç…§éœ€è¦å¯¹ç³»ç»Ÿè¿›è¡Œå¯è§†åŒ– å…è®¸æˆ‘ä»¬è¯¦ç»†è¯´æ˜ç³»ç»Ÿçš„ç»“æ„å’Œè¡Œä¸º ç»™å‡ºäº†ä¸€ä¸ªæŒ‡å¯¼æˆ‘ä»¬æ„é€ ç³»ç»Ÿçš„æ¨¡æ¿ å¯¹æˆ‘ä»¬æ‰€åšå‡ºçš„å†³ç­–è¿›è¡Œæ–‡æ¡£åŒ– å»ºæ¨¡çš„å››é¡¹åŸºæœ¬åŸç† é€‰æ‹©è¦åˆ›å»ºä»€ä¹ˆæ¨¡å‹ æ¯ä¸€ç§æ¨¡å‹å¯ä»¥åœ¨ä¸åŒçš„ç²¾åº¦çº§åˆ«ä¸Šè¡¨ç¤º æœ€å¥½çš„æ¨¡å‹æ˜¯ä¸ç°å®ç›¸å…³è”çš„ å•ä¸ªæ¨¡å‹æ˜¯ä¸å……åˆ†çš„, å¯¹æ¯ä¸€ä¸ªé‡è¦çš„ç³»ç»Ÿæœ€å¥½ç”¨ä¸€ç»„å‡ ä¹ç‹¬ç«‹çš„æ¨¡å‹å»å¤„ç†","link":"/2020/07/01/UML-Lec01-02/"},{"title":"MapReduce","text":"","link":"/2021/01/28/MapReduce/"},{"title":"UML_Lec02_b1","text":"UML æ„é€ å—$UML$ äº‹ç‰© ç»“æ„äº‹ç‰© ç±» æ¥å£ åä½œ ç”¨ä¾‹ ä¸»åŠ¨ç±» èŠ‚ç‚¹ æ„ä»¶ åˆ¶å“ è¡Œä¸ºäº‹ç‰© äº¤äº’ çŠ¶æ€æœº æ´»åŠ¨ åˆ†ç»„äº‹ç‰© åŒ… æ³¨é‡Šäº‹ç‰© æ³¨é‡Š å…³ç³» ä¾èµ– å…³è” æ³›åŒ– å®ç° å›¾ ç±»å›¾ å¯¹è±¡å›¾ é¡ºåºå›¾ é€šä¿¡å›¾ æ„ä»¶å›¾ æ´»åŠ¨å›¾ åˆ¶å“å›¾ åŒ…å›¾ æ—¶åºå›¾ ç”¨ä¾‹å›¾ çŠ¶æ€å›¾ éƒ¨ç½²å›¾ äº¤äº’æ¦‚è§ˆå›¾ å¯¹ç³»ç»Ÿçš„ä½“ç³»ç»“æ„å»ºæ¨¡$â€4+1â€$ view","link":"/2020/07/01/UML-Lec02-b1/"},{"title":"Redisæ•°æ®ç±»å‹ï¼šstring","text":"å†™åœ¨å‰é¢å¯’å‡åœ¨å®¶æ— èŠï¼Œå°±æƒ³ç€çœ‹çœ‹ Redis5.0 çš„æºç ï¼Œåˆšå¥½åœ¨çŸ¥ä¹ä¹Ÿçœ‹è§ä¸€ä¸ªå†™çš„ä¸é”™çš„ç¬”è®°ï¼Œå°±é¡ºç€å®ƒçš„å­¦ä¹ è·¯çº¿çœ‹ä»£ç äº† Redis æ˜¯ä»€ä¹ˆï¼ŸRedis æ˜¯ä¸€ä¸ªä½¿ç”¨ ANSI C ç¼–å†™çš„å¼€æºã€æ”¯æŒç½‘ç»œã€åŸºäºå†…å­˜ã€åˆ†å¸ƒå¼ã€å¯æŒä¹…æ€§çš„é”®å€¼å¯¹å­˜å‚¨æ•°æ®åº“ï¼ˆwiki ç™¾ç§‘ï¼‰ã€‚ Redis æ”¯æŒå“ªäº›æ•°æ®ç±»å‹ï¼Ÿ å­—ç¬¦ä¸² å­—ç¬¦ä¸²åˆ—è¡¨ æ— åºä¸é‡å¤çš„å­—ç¬¦ä¸²é›†åˆ æœ‰åºä¸é‡å¤çš„å­—ç¬¦ä¸²é›†åˆ é”®ã€å€¼éƒ½ä¸ºå­—ç¬¦ä¸²çš„å“ˆå¸Œè¡¨ æŒä¹…åŒ–Redis ä¸€èˆ¬å°†å…¨éƒ¨çš„æ•°æ®éƒ½å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œç›®å‰é€šè¿‡ä¸¤ç§æ–¹æ³•å®ç°æŒä¹…åŒ–ï¼š å¿«ç…§ï¼Œä¸€ç§åŠæŒä¹…å†…ç”¨æ¨¡å¼ã€‚ä¸æ—¶åœ°å°†æ•°æ®é›†ä»¥å¼‚æ­¥çš„æ–¹å¼ä»å†…å­˜ä»¥ RDB æ ¼å¼å†™å…¥ç¡¬ç›˜ã€‚ 1.1 ç‰ˆæœ¬å¼€å§‹ä½¿ç”¨æ›´å®‰å…¨çš„ AOF æ ¼å¼æ›¿ä»£ï¼Œä¸€ç§åªèƒ½è¿½åŠ çš„æ—¥å¿—ç±»å‹ã€‚å°†æ•°æ®é›†ä¿®æ”¹æ“ä½œè®°å½•èµ·æ¥ã€‚Redis èƒ½å¤Ÿåœ¨åå°å¯¹åªå¯è¿½åŠ çš„è®°å½•ä½œä¿®æ”¹æ¥é¿å…æ— é™å¢é•¿çš„æ—¥å¿— åŒæ­¥Redis æ”¯æŒä¸»ä»åŒæ­¥ã€‚æ•°æ®å¯ä»¥ä»ä¸»æœåŠ¡å™¨å‘ä»»æ„æ•°é‡çš„æœåŠ¡å™¨ä¸ŠåŒæ­¥ï¼Œä»æœåŠ¡å™¨å¯ä»¥ä½¿å…³è”å…¶ä»–ä»æœåŠ¡å™¨çš„ä¸»æœåŠ¡å™¨ï¼Œè¿™ä½¿å¾— Redis å¯æ‰§è¡Œå•å±‚æ ‘å¤åˆ¶ã€‚ä»ç›˜å¯ä»¥æœ‰æ„æ— æ„çš„å¯¹æ•°æ®è¿›è¡Œå†™æ“ä½œã€‚ç”±äºå®Œå…¨å®ç°äº†å‘å¸ƒ/è®¢é˜…æœºåˆ¶ï¼Œä½¿å¾—ä»æ•°æ®åº“åœ¨ä»»ä½•åœ°æ–¹åŒæ­¥æ ‘æ—¶ï¼Œå¯è®¢é˜…ä¸€ä¸ªé¢‘é“å¹¶æ¥æ”¶ä¸»æœåŠ¡å™¨å®Œæ•´çš„æ¶ˆæ¯å‘å¸ƒè®°å½•ã€‚åŒæ­¥å¯¹è¯»å–æ“ä½œçš„å¯æ‰©å±•æ€§å’Œæ•°æ®å†—ä½™å¾ˆæœ‰å¸®åŠ©ã€‚ï¼ˆè®²é“ç†è¿™äº›æˆ‘ç°åœ¨ä¹Ÿä¸æ˜¯å¾ˆæ‡‚ã€‚ã€‚ã€‚ï¼‰ æ€§èƒ½å½“æ•°æ®ä¾èµ–ä¸å†éœ€è¦ï¼ŒRedisè¿™ç§åŸºäºå†…å­˜çš„æ€§è´¨ï¼Œä¸åœ¨æ‰§è¡Œä¸€ä¸ªäº‹åŠ¡æ—¶å°†æ¯ä¸ªå˜åŒ–éƒ½å†™å…¥ç¡¬ç›˜çš„æ•°æ®åº“ç³»ç»Ÿç›¸æ¯”å°±æ˜¾å¾—æ‰§è¡Œæ•ˆç‡éå¸¸é«˜ã€‚å†™ä¸è¯»æ“ä½œé€Ÿåº¦æ²¡æœ‰æ˜æ˜¾å·®åˆ« Redis ä¸­çš„ string â€”â€” sdshdræ•°æ®ç±»å‹Redis5.0 ä¸­å®šä¹‰äº†äº”ç§ string ç±»å‹ï¼š sdshdr5 sdshdr8 sdshdr16 sdshdr32 sdshdr64 æ²¡é”™ï¼Œåé¢çš„æ•°å­—åç¼€ä»£è¡¨äº†èƒ½å­˜å‚¨çš„å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ã€‚æˆ‘ä»¬å…ˆæ¥çœ‹åé¢å››ç§ï¼Œä»–ä»¬éƒ½å…·æœ‰ç›¸åŒçš„ç»“æ„ï¼š 123456struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; // å·²ä½¿ç”¨é•¿åº¦ uint8_t alloc; // æ€»çš„å¤§å° unsigned char flags; // ç¬¬ä¸‰ä½è®°å½•ç±»å‹ï¼Œé«˜äº”ä½æ— ç”¨å¤„ char buf[]; // å®é™…å­—ç¬¦ç¼“å­˜}; æ‰€ä»¥ï¼Œsdshdr ç±»å‹çš„ç»“æ„å›¾å¦‚ä¸‹ï¼š å›¾æºï¼š ä¹Ÿå°±æ˜¯è¯´ï¼Œsdshdr åœ¨å†…å­˜ä¸­çš„æ ¼å¼ä¸ºä¸€ä¸ª Header å­—æ®µåŠ ä¸Šä¸€æ®µè¿ç»­å†…å­˜ã€‚sds å°±æ˜¯å®é™…å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ã€‚ ç”±äºåªæœ‰ 5 ç§ç±»å‹ï¼Œæ‰€ä»¥ç”¨ä¸€ä¸ª unsigned char ç±»å‹è¶³å¤Ÿæè¿°è¯¥ç§ sdshdr ç±»å‹ï¼ŒRedis ä¸­å®šä¹‰äº†å‡ ç§ type: 1234567#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7#define SDS_TYPE_BITS 3 æ˜¾ç„¶ï¼Œé€šè¿‡ flags å­—æ®µä¸ SDS_TYPE_MASK åšä½ä¸è¿ç®—ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å…¶ç±»å‹ï¼Œè€Œç”±äºç»“æ„ä½“ä½¿ç”¨çš„æ˜¯éå¯¹é½ç±»å‹ï¼ˆ__attribute__ ((__packed__))ï¼‰ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ç›´æ¥é€šè¿‡è®¿é—® s[-1] å³å¯è·å¾—å…¶å¤´éƒ¨ä¿¡æ¯ã€‚ï¼ˆè®²é“ç†æˆ‘çœ‹åˆ°è¿™ä¸ªä¹Ÿå‚»äº†ï¼Œè¿™ä¸æ˜¯ runtime error å—ï¼Ÿä½†æ˜¯è½¬å¤´ä¸€æƒ³ï¼Œé‡Œé¢çš„æ•°å­—ä¸è¿‡æ˜¯ä¸ªåç§»é‡ç½¢äº†ï¼Œåªè¦ä½ è®¿é—®çš„é‚£æ®µå†…å­˜æ˜¯æœ‰æ•ˆçš„ï¼Œåˆæ€ä¹ˆä¼šäº§ç”Ÿæ®µé”™è¯¯å‘¢ï¼Ÿï¼‰ ç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹ sdshdr5 å§ï¼Œä»–çš„ç»“æ„å¦‚ä¸‹ï¼š 12345struct __attribute__ ((__packed__)) sdshdr5{ unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[];}; è¿™æ ·çœ‹ä¸Šå»ï¼Œå¥½åƒ sdshdr5 å°±æ˜¯ä¸ºäº†é‚£äº›è¾ƒçŸ­çš„å­—ç¬¦ä¸²ï¼ˆä¸è¶…è¿‡ 32 ä¸ªå­—èŠ‚ï¼‰å‡†å¤‡çš„å§ï¼Œåƒæ˜¯ä¸€ç§é™æ€çš„ç±»å‹ã€‚å¯¹æ­¤ï¼ŒRedis çš„ä½œè€…ä¹Ÿç»™å‡ºäº†å»ºè®®ï¼š Don't use TYPE 5 if strings are going to be reallocated, since it sucks not having a free space left field. ï¼ˆè°ä¼šç»™ 32 ä¸ªå­—èŠ‚çš„ä¸œè¥¿é‡æ–°åˆ†é…å¤§å°å‘¢ï¼Ÿï¼‰ é€šç”¨åº•å±‚æ“ä½œåœ¨æºç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è®¸å¤šçš„å®å®šä¹‰ï¼š 1#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) è®²é“ç† struct sdshdr##T æ˜¯å•¥æ„æ€æˆ‘çœŸä¸æ˜ç™½ï¼Œä¹Ÿæ²¡æ‰¾åˆ°ï¼Œæˆ‘ä»¬ç»“åˆä½¿ç”¨äº†è¿™ä¸ªå®å®šä¹‰çš„å‡½æ•°æ¥çœ‹çœ‹ï¼š 12345678910111213141516static inline size_t sdslen(const sds s) { unsigned char flags = s[-1]; switch(flags&SDS_TYPE_MASK) { case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)->len; case SDS_TYPE_16: return SDS_HDR(16,s)->len; case SDS_TYPE_32: return SDS_HDR(32,s)->len; case SDS_TYPE_64: return SDS_HDR(64,s)->len; } return 0;} ä»åå­—ä¸éš¾å¾—å‡ºï¼Œè¿™å°±æ˜¯è¿”å› string é•¿åº¦çš„ï¼Œä¹Ÿå°±æ˜¯ Header ä¸­çš„ len å­—æ®µï¼Œæ³¨æ„ä¼ é€’è¿›æ¥çš„ sds å°±æ˜¯ char * ã€‚ å¾ˆæ˜æ˜¾ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡ä¼ é€’è¿›æ¥çš„ sds æ•°æ®å¾—åˆ°å¯¹åº”çš„ Header æŒ‡é’ˆï¼Œè¿™æ ·æˆ‘ä»¬æ‰èƒ½è®¿é—® len å­—æ®µï¼Œé‚£ä¸Šé¢çš„å¼å­å°±å¥½ç†è§£äº†å•Šï¼##T åº”è¯¥æ˜¯è¢«æ›¿æ¢æˆäº†ç›¸åº”çš„æ•°å­—ï¼Œå¾ˆå·§å¦™çš„è®¾è®¡ï¼å› ä¸ºç»“æ„ä½“ä¸­çš„ char buf[] æ˜¯ä¸å å†…å­˜çš„ï¼Œè¿™æ ·æˆ‘ä»¬å°±ç›´æ¥è®¿é—®åˆ°äº† Header çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼Œåé¢ä»£ç ä¸­å¾ˆå¤šåœ°æ–¹éƒ½å·§å¦™åœ°åˆ©ç”¨äº†è¿™ä¸€ç‚¹ã€‚ 1#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); è¿™ä¸€å¥ç›¸æ¯”ä¹Ÿå¾ˆæ˜ç™½äº†ï¼Œå®šä¹‰äº†ä¸€ä¸ªå…¨å±€å˜é‡ shï¼Œä»–èƒ½æŒ‡å‘å¯¹åº”å­—ç¬¦ä¸²çš„ Header å­—æ®µçš„ç¬¬ä¸€ä¸ªå­—èŠ‚ã€‚ æ¥ä¸‹æ¥å°±æ˜¯ä¸€äº›å­—é¢æ„æ€çš„å‡½æ•°äº†ï¼š 1static inline size_t sdsavail(const sds s) è®¡ç®—è¿˜æœ‰å¤šå°‘å¯ç”¨ç©ºé—´ 1static inline void sdssetlen(sds s, size_t newlen) è®¾ç½®æ–°é•¿åº¦ 1static inline void sdsinclen(sds s, size_t inc) å¢åŠ é•¿åº¦ 1static inline size_t sdsalloc(const sds s) å¾—åˆ°æ€»ç©ºé—´ 1static inline void sdssetalloc(sds s, size_t newlen) é‡ç½®æ€»ç©ºé—´ å„ç§æ“ä½œå‡½æ•°123static inline char sdsReqType(size_t string_size);static inline int sdsHdrSzie(char type);static inline size_t sdsTypeMaxSize(char type) è¿™æ˜¯ä½ä¸ src/sds.c ä¸­çš„ä¸¤ä¸ªé™æ€å‡½æ•°ï¼Œåˆ†åˆ«ç”¨äºè¿”å›ä¸€ä¸ªç‰¹å®š HeaderTypeçš„å¤´éƒ¨ç»“æ„ä½“é•¿åº¦ã€æ ¹æ®ä¸€ä¸ª string_size çš„é•¿åº¦ï¼Œè¿”å›åˆé€‚çš„ HeaderTypeã€ä»¥åŠæ ¹æ® type è¿”å›æœ€å¤§å®¹é‡ã€‚ 1sds _sdsnewlen(const void *init, size_t initlen, int trymalloc); è¿™æ˜¯æ ¹æ®ç»™å®šçš„ init æŒ‡é’ˆå’Œ initlen é•¿åº¦ æ¥åˆ›å»ºä¸€ä¸ª sds çš„å‡½æ•°ï¼Œä»–çš„å®ç°è¿˜æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œå…·ä½“æè¿°å¦‚ä¸‹ï¼š æˆ‘ä»¬æ ¹æ®ç»™å®šçš„é•¿åº¦è¿”å›ä¸€ä¸ª HeaderTypeï¼Œæ¯”å¦‚ï¼š5ï¼Œ8ï¼Œ16ï¼Œ32 æˆ–è€… 64ï¼Œç„¶åå¯¹ä¸€ä¸ª void * ç±»å‹çš„å˜é‡è¿›è¡Œåˆå§‹åŒ–ï¼Œé•¿åº¦ä¸º initlen+hdrlen+1ï¼ŒåŠ ä¸€æ˜¯æœ‰è®²ç©¶çš„ï¼Œå› ä¸ºåœ¨ Redis ä¸­ sds æ€»æ˜¯ä»¥ '\\0' ä½œä¸ºç»“å°¾çš„ï¼Œæ‰€ä»¥éœ€è¦å¤šåˆ†é…ä¸€ä¸ªå­—èŠ‚çš„å†…å­˜ï¼Œå“ªæœ‰çš„å°ä¼™ä¼´å°±æœ‰ç–‘é—®äº†ï¼Œè¦æ˜¯æ•°æ®ä¸­å‡ºç°äº† '\\0' æ€ä¹ˆåŠï¼Ÿè¿™ç‚¹å®Œå…¨ä¸ç”¨æ‹…å¿ƒï¼Œå› ä¸ºæˆ‘ä»¬æœ‰ len å­—æ®µå•Šã€‚ä¹‹åæˆ‘ä»¬ä¼šåˆå§‹åŒ– Header ä¸­çš„å„ä¸ªå­—æ®µï¼Œå¹¶å°† init ä¸­çš„å†…å®¹æ‹·è´åˆ° sds çš„ç¼“å†²åŒºï¼Œä»¥ '\\0' ç»“å°¾ã€‚ 12345678910111213141516171819202122sds sdsnewlen(const void *init, size_t initlen) { return _sdsnewlen(init, initlen, 0);}sds sdstrynewlen(const void *init, size_t initlen) { return _sdsnewlen(init, initlen, 1);}/* Create an empty (zero length) sds string. Even in this case the string * always has an implicit null term. */sds sdsempty(void) { return sdsnewlen(\"\",0);}/* Create a new sds string starting from a null terminated C string. */sds sdsnew(const char *init) { size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);}/* Duplicate an sds string. */sds sdsdup(const sds s) { return sdsnewlen(s, sdslen(s));} è¿™äº›å‡½æ•°éƒ½å¾ˆç®€å•ï¼Œå¯¹ç€ä¸Šé¢çœ‹å°± ok äº†ï¼Œä½†æ˜¯æœ‰å…³å†…å­˜åˆ†é…æˆ‘å…¶å®å¹¶æ²¡æœ‰è®²ï¼Œè¿™ä¸€å—ç¡®å®æ¯”è¾ƒå¤§ï¼Œæˆ‘æ‰“ç®—ä»¥åå•ç‹¬æ‹å‡ºæ¥ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä»¥ä¸ªæ¯”è¾ƒæœ‰æ„æ€çš„å‡½æ•° 1sds sdsMakeRoomFor(sds s, size_t addlen); è¿™ä¸ªæ¥å£ç”¨äºç»™ä¸€ä¸ªç»™å®šçš„å­—ç¬¦ä¸²æ‰©å®¹ï¼Œå¯ä»¥ç¡®ä¿ç”¨æˆ·åœ¨è°ƒç”¨è¿™ä¸ªæ¥å£ä¹‹åï¼Œå¯ä»¥å‘ç¼“å­˜ä¹‹ä¸­ç»­å†™ addlen ä¸ªå­—èŠ‚çš„å†…å®¹ï¼Œä½†æ˜¯è¿™ä¸ªæ“ä½œä¸ä¼šæ”¹å˜å·²ç»ä½¿ç”¨çš„ç¼“å­˜çš„å¤§å°ï¼Œä¹Ÿå°±æ˜¯ä¸ä¼šæ”¹å˜ sdslen è°ƒç”¨çš„ç»“æœã€‚è¿™ä¸ªå‡½æ•°æœ‰ç‚¹å„¿å¤æ‚ï¼Œæˆ‘å°±ä¸è®²ç å¾·ç›´æ¥ä¸Šä»£ç äº†ã€‚ã€‚ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh, *newsh; // è®¡ç®—å‰©ä½™ç©ºé—´ size_t avail = sdsavail(s); size_t len, newlen; char type, oldtype = s[-1] & SDS_TYPE_MASK; int hdrlen; size_t usable; /* å¦‚æœå‰©ä½™ç©ºé—´è¶³å¤Ÿçš„è¯ï¼Œå°±åŸå°ä¸åŠ¨è¿”å› */ if (avail >= addlen) return s; // å‚æ•°å­—ç¬¦ä¸²é•¿åº¦ len = sdslen(s); // è·å– Header æŒ‡é’ˆ sh = (char*)s-sdsHdrSize(oldtype); newlen = (len+addlen); // è¿™é‡Œçš„ç›®çš„æ˜¯å‡å°‘å¤šæ¬¡æ‰©å®¹å¸¦æ¥å¼€é”€ï¼Œç´¢æ€§ä¸€æ¬¡ç»™å¤šç‚¹ï¼Œ1024 * 1024ï¼Œä¹Ÿå°±æ˜¯ 1MB if (newlen < SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; // è·å¾—æ–°ç±»å‹ type = sdsReqType(newlen); // æç¤ºå¥½å¥½çœ‹ï¼Œå°±æ˜¯åˆ«ç”¨ sdshdr5 /* Don't use type 5: the user is appending to the string and type 5 is * not able to remember empty space, so sdsMakeRoomFor() must be called * at every appending operation. */ if (type == SDS_TYPE_5) type = SDS_TYPE_8; hdrlen = sdsHdrSize(type); // æ²¡æœ‰å¼•å‘å‡çº§ if (oldtype==type) { newsh = s_realloc_usable(sh, hdrlen+newlen+1, &usable); if (newsh == NULL) return NULL; s = (char*)newsh+hdrlen; } else { // å‡çº§äº†çš„è¯ä¼šæ„é€ ä¸€ä¸ªæ–°çš„ sds /* Since the header size changes, need to move the string forward, * and can't use realloc */ newsh = s_malloc_usable(hdrlen+newlen+1, &usable); if (newsh == NULL) return NULL; memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh+hdrlen; s[-1] = type; sdssetlen(s, len); } usable = usable-hdrlen-1; if (usable > sdsTypeMaxSize(type)) usable = sdsTypeMaxSize(type); sdssetalloc(s, usable); return s;} å°¤å…¶æ˜¯æœ€åä¸€ç‚¹ï¼Œå‡çº§å°†ä¼šå¯¼è‡´åˆ†é…ä¸€ä¸ªæ–°çš„ sdsï¼Œç„¶åè¿”å›æ–°çš„æŒ‡é’ˆï¼Œè¿™ä¹Ÿå°±æ„å‘³ç€è°ƒç”¨è€…æ— æ³•ä¿è¯ä½œä¸ºå‚æ•°ä¼ å…¥çš„ sds æŒ‡é’ˆåœ¨è°ƒç”¨ç»“æŸåæ˜¯å¦æœ‰æ•ˆï¼Œå¯¹æ­¤ï¼Œä½œè€…ç»™å‡ºäº†å»ºè®®ï¼š Don't call sdsMakeRoomFor() when obviously not needed. å‰©ä¸‹çš„å°±æ˜¯å¤„ç†å†…å®¹çš„å‡½æ•°äº†ï¼Œè¿™äº›æˆ‘å°±è‡ªä¸ªå„¿æ…¢æ…¢çœ‹äº†ï¼ˆæˆ–è€…å’•æ‰ï¼‰ï¼Œéƒ½ä¸æ˜¯å¾ˆå¤æ‚ï¼Œç±»ä¼¼äº C ä¸­çš„ä¸€äº›å¤„ç†å‡½æ•°ï¼Œåªä¸è¿‡è¦æ³¨æ„å¤„ç† Header å­—æ®µã€‚","link":"/2021/02/09/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Astring/"},{"title":"UML-Lec03","text":"å››ç§å…³ç³» å…³è”å…³ç³» å®çº¿+æ— ç®­å¤´ ä¾èµ–å…³ç³» ç®­å¤´æŒ‡å‘è¢«ä¾èµ–çš„ä¸€æ–¹ è™šçº¿+å‰ç®­å¤´ ç»§æ‰¿å…³ç³»ï¼ˆæ³›åŒ–å…³ç³»ï¼‰ å®çº¿+ç©ºå¿ƒç®­å¤´ å®ç°å…³ç³» è™šçº¿+ç©ºå¿ƒç®­å¤´ å‚ä¸è€…ä¸å‚ä¸è€… æ³›åŒ–å…³ç³» å‚ä¸è€…ä¸ç”¨ä¾‹ å…³è”å…³ç³» ç”¨ä¾‹ä¸ç”¨ä¾‹ æ³›åŒ–å…³ç³» åŒ…å«å…³ç³»ï¼šåŸºç”¨ä¾‹æŒ‡å‘å­ç”¨ä¾‹ æ‰©å±•å…³ç³»ï¼šå­ç”¨ä¾‹æŒ‡å‘åŸºç”¨ä¾‹","link":"/2020/09/05/UML-Lec03/"},{"title":"UML_Lec02_b2","text":"$UML$ å’Œé¢å‘å¯¹è±¡ $UML$ ä¸æ˜¯é¢å‘å¯¹è±¡çš„æŠ€æœ¯ $UML$ çš„ç¬¦å·ã€è¯­ä¹‰å¯ä»¥ç”¨æ¥æè¿°é¢å‘å¯¹è±¡çš„æ¦‚å¿µ é‡è½½å’Œé‡å†™ é‡å†™ï¼Œä¹Ÿå«è¦†ç›–ï¼Œæ˜¯æŒ‡åœ¨å­ç±»ä¸­é‡æ–°å®šä¹‰çˆ¶ç±»çš„å‡½æ•° é‡è½½æŒ‡åœ¨åŒä¸€ä¸ªç±»ä¸­å‡ºç°å¤šä¸ªåŒåçš„æ–¹æ³•çš„ç°è±¡ï¼Œé‡è½½å‘ç”Ÿåœ¨åŒä¸€ä¸ªç±»ä¸­ å¤šæ€å’Œå¤šæ€æ€§ å¤šæ€æŒ‡çš„æ˜¯ä¸€ç±»äº‹ç‰©æœ‰å¤šç§å½¢æ€ï¼Œï¼ˆä¸€ä¸ªæŠ½è±¡ç±»æœ‰å¤šä¸ªå­ç±»ï¼Œå› è€Œå¤šæ€çš„æ¦‚å¿µä¾èµ–äºç»§æ‰¿ï¼‰ åºåˆ—æ•°æ®ç±»å‹æœ‰å¤šç§å½¢æ€ï¼šå­—ç¬¦ä¸²ï¼Œåˆ—è¡¨ï¼Œå…ƒç»„ åŠ¨ç‰©æœ‰å¤šç§å½¢æ€ï¼šäººï¼ŒğŸ•ï¼ŒğŸ– å¤šæ€æ€§æ˜¯æŒ‡å…·æœ‰ä¸åŒåŠŸèƒ½çš„å‡½æ•°å¯ä»¥ä½¿ç”¨ç›¸åŒçš„å‡½æ•°åï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ä¸€ä¸ªå‡½æ•°åè°ƒç”¨ä¸åŒå†…å®¹çš„å‡½æ•°ã€‚åœ¨é¢å‘å¯¹è±¡æ–¹æ³•ä¸­ä¸€èˆ¬æ˜¯è¿™æ ·è¡¨è¿°å¤šæ€æ€§ï¼šå‘ä¸åŒçš„å¯¹è±¡å‘é€åŒä¸€æ¡æ¶ˆæ¯ï¼Œä¸åŒçš„å¯¹è±¡åœ¨æ¥æ”¶æ—¶ä¼šäº§ç”Ÿä¸åŒçš„è¡Œä¸ºã€‚ å¤šæ€æ€§çš„å¥½å¤„ å¢åŠ äº†ç¨‹åºçš„çµæ´»æ€§ å¢åŠ äº†ç¨‹åºçš„å¯æ‰©å±•æ€§","link":"/2020/07/02/UML-Lec02-b2/"},{"title":"UML-Lec06","text":"å…¬å…±æœºåˆ¶ ä¿®é¥° æ³¨é‡Š å¯è§æ€§ã€è§’è‰²ã€å¤šé‡æ€§ æ‰©å……æœºåˆ¶ æ„é€ å‹ æ ‡è®°å€¼ çº¦æŸ è§„æ ¼è¯´æ˜ å…¬ç”¨åˆ’åˆ† æ‰©å……æœºåˆ¶æ„é€ å‹ç±»ä¼¼äºå·²æœ‰çš„ UML å»ºæ¨¡å…ƒç´ åˆæ˜¯å¯¹ç‰¹å®šé—®é¢˜é¢†åŸŸå…·æœ‰ç‰¹æ®Šå«ä¹‰çš„æ–°çš„å»ºæ¨¡å…ƒç´  æ ‡è®°å€¼åœ¨å»ºæ¨¡è¿‡ç¨‹ä¸­ï¼Œ å‡ºäºæŸç§åŸå› éœ€è¦å¢åŠ ä¸€ä¸ªæ–°çš„æ„æˆä»¥è¡¨è¾¾å»ºæ¨¡å…ƒç´ çš„æŸç§ç‰¹æ€§ï¼Œç”¨èŠ±æ‹¬å·æ‹¬èµ·æ¥ çº¦æŸä¸ºå¯¹åº”çš„å»ºæ¨¡å…ƒç´ è§„å®šäº†ä¸€ä¸ªæ¡ä»¶ï¼Œç”¨èŠ±æ‹¬å·æ‹¬èµ·æ¥ ç±»çš„æ‰©å……æœºåˆ¶ æ§åˆ¶ç±» è¾¹ç•Œç±» å®ä½“ç±» ä»–ä»¬éƒ½æ˜¯ç±»çš„æ„é€ å‹","link":"/2020/09/05/UML-Lec06/"},{"title":"UML-Lec05","text":"ç±»ç±»çš„å®šä¹‰ï¼šå…·æœ‰ç›¸åŒå±æ€§ã€ç›¸åŒè¡Œä¸ºçš„ä¸€ç»„å¯¹è±¡çš„æè¿°ç¬¦ï¼Œæ˜¯çœŸå®ä¸–ç•Œäº‹ç‰©çš„æŠ½è±¡ ç±»çš„è¡¨ç¤ºâ€“è´£èŒ æ˜¯ç±»çš„åˆçº¦æˆ–è´£ä»» ä¸€ä¸ªè‰¯å¥½å®šä¹‰çš„ç±»åº”è¯¥æœ‰æ¸…æ™°çš„èŒè´£ ä¸€ä¸ªç±»åº”åªæ‰¿æ‹…ä¸€ç§èŒè´£ ç±»çš„èŒè´£åˆ’åˆ†çš„å¥½åï¼Œå†³å®šäº†è®¾è®¡æ–¹æ¡ˆçš„å†…èšæ€§åŠè€¦åˆæ€§ å…³ç³» ä¾èµ–å…³ç³»ï¼šè¯´æ˜ä¸€ä¸ªäº‹ç‰©ä½¿ç”¨å¦ä¸€ä¸ªäº‹ç‰©çš„ä¿¡æ¯å’ŒæœåŠ¡ æ³›åŒ–å…³ç³»ï¼šå­ç±»å’Œçˆ¶ç±»ä¹‹é—´ å…³è”å…³ç³» å…³è”å…³ç³»çš„ä¿®é¥° åç§°åŠå…¶æ–¹å‘ è§’è‰²ï¼šåœ¨å…³è”çš„æ¯ä¸€ç«¯ï¼Œè¡¨æ˜å’Œç›¸è¿çš„ç±»åœ¨è¯¥å…³è”å…³ç³»ä¸­çš„ä½œç”¨ å¤šé‡æ€§èšåˆ/ç»„åˆ èšåˆï¼šæ•´ä½“æœ‰ç®¡ç†éƒ¨åˆ†çš„ç‰¹æœ‰çš„èŒè´£ï¼Œç©ºè±å½¢ ç»„åˆï¼šæ•´ä½“æœ‰éƒ¨åˆ†çš„ç”Ÿå‘½ï¼Œå®è±å½¢","link":"/2020/09/05/UML-Lec05/"},{"title":"electron-ipcMain.md","text":"ipcMainä»ä¸»è¿›ç¨‹åˆ°æ¸²æŸ“è¿›ç¨‹çš„å¼‚æ­¥é€šä¿¡ã€‚å½“åœ¨ä¸»è¿›ç¨‹ä¸­ä½¿ç”¨æ—¶ï¼Œå®ƒå¤„ç†ä»æ¸²æŸ“è¿›ç¨‹ï¼ˆç½‘é¡µï¼‰å‘é€å‡ºæ¥çš„å¼‚æ­¥å’ŒåŒæ­¥ä¿¡æ¯ã€‚ä»æ¸²æŸ“å™¨è¿›ç¨‹å‘é€çš„æ¶ˆæ¯å°†å‘é€åˆ°è¯¥æ¨¡å—ã€‚ å‘é€æ¶ˆæ¯ä¹Ÿå¯ä»¥ä»ä¸»è¿›ç¨‹å‘æ¸²æŸ“è¿›ç¨‹å‘é€æ¶ˆæ¯ã€‚ å‘é€æ¶ˆæ¯ï¼Œäº‹ä»¶åç§°ä¸º channel å›å¤åŒæ­¥ä¿¡æ¯æ—¶ï¼Œéœ€è¦è®¾ç½® event.returnValue å¯ä»¥ä½¿ç”¨ event.sender.send() å°†å¼‚æ­¥æ¶ˆæ¯å‘å›å‘é€è€…ã€‚ ä¾‹å­ï¼š 1234567891011// ä¸»è¿›ç¨‹const { ipcMain } = require('electron')ipcMain.on('asynchronous-message', (event, arg) => { console.log(arg) event.reply('asynchronous-reply', 'pong')})ipcMain.on('synchronous-message', (event, arg) => { console.log(arg) event.returnValue = 'pong'}) 12345678// æ¸²æŸ“è¿›ç¨‹const { ipaRenderer } = require('electron')console.log(ipcRenderer.sendSync('synchronous-message', 'ping'))ipcRenderer.on('asynchronous-reply', (event, arg) => { console.log(arg)})ipcRenderer.send('asynchronous-message', 'ping') æ–¹æ³•ipcMain.on(channel, listener) channel String listener Function event IpcMainEvent ...args any[] ç›‘å¬ channelï¼Œå½“æ¥æ”¶åˆ°æ–°çš„æ¶ˆæ¯æ—¶ listener ä¼šä»¥ listener(event, args) çš„å½¢å¼è¢«è°ƒç”¨ã€‚ ipcMain.once(channel, listener) channel String listener Function event IpcMainEvent ...args any[] ä¸ºäº‹ä»¶æ·»åŠ ä¸€æ¬¡ç›‘å¬å™¨åŠŸèƒ½ï¼Œä»…åœ¨ä¸‹æ¬¡å°†æ¶ˆæ¯å‘é€åˆ°é€šé“æ—¶æ‰è°ƒç”¨æ­¤ä¾¦å¬å™¨ï¼Œç„¶åå°†å…¶åˆ é™¤ã€‚ ipcMain.removeListener(channel, listener) channel String listener Function ...args any[] ä»ç›‘å¬å™¨æ•°ç»„ä¸­ç§»é™¤ç›‘å¬ channel çš„æŒ‡å®š listener ã€‚ ipcMain.removeAllListeners([channel]) channel String (optional) åˆ é™¤æ‰€æœ‰ç›‘å¬è€…ï¼Œæˆ–æŒ‡å®šçš„ channel çš„æ‰€æœ‰ç›‘å¬è€…ã€‚ ipcMain.handle(channel, listener) channel String listener Function event IpcMainInvokeEvent ...args any[] ä¸ºå¯è°ƒç”¨çš„ IPC æ·»åŠ å¤„ç†ç¨‹åºã€‚æ¯å½“æ¸²æŸ“å™¨ç¨‹åºè°ƒç”¨ ipcRenderer.invoke(channel, ...args) éƒ½ä¼šè°ƒç”¨è¿™ä¸ªå¤„ç†ç¨‹åºã€‚ å¦‚æœ listener è¿”å›ä¸€ä¸ª Promise ï¼Œåˆ™ Promise çš„æœ€ç»ˆç»“æœå°†ä½œä¸ºå¯¹è¿œç¨‹è°ƒç”¨è€…çš„ç­”å¤è€Œè¿”å›ã€‚å¦åˆ™ï¼Œlistener çš„è¿”å›å€¼å°†ç”¨ä½œå›å¤çš„å€¼ã€‚ 1234567891011// Main processipcMain.handle('my-invokable-ipc', async (event, ...args) => { const result = await somePromise(...args) return result})// Renderer processasync () => { const result = await ipcRenderer.invoke('my-invokable-ipc', arg1, arg2) // ...} ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’ç»™å¤„ç†ç¨‹åºçš„äº‹ä»¶ä¸ä¼ é€’ç»™å¸¸è§„äº‹ä»¶ä¾¦å¬å™¨çš„äº‹ä»¶ç›¸åŒï¼Œå®ƒåŒ…å«æœ‰å…³å“ªäº› WebContents æ˜¯è°ƒç”¨è¯·æ±‚æºçš„ä¿¡æ¯ã€‚ ipcMain.handleOnce(channel, listener) channel String listener Function event IpcMainInvokeEvent ...args any[] å¤„ç†å•ä¸ªå¯è°ƒç”¨çš„ IPC æ¶ˆæ¯ï¼Œç„¶ååˆ é™¤ä¾¦å¬å™¨ ipcMain.removeHandler(channel) channel String ä¸º channel åˆ é™¤æ‰€æœ‰å¤„ç†ç¨‹åºã€‚ ipcMainEvent Object extends Event frameID Integer - å‘é€è¯¥æ¶ˆæ¯çš„æ¸²æŸ“è¿›ç¨‹æ¡†æ¶çš„ ID returnValue any - å°†å…¶è®¾ç½®ä¸ºè¦åœ¨åŒæ­¥æ¶ˆæ¯ä¸­è¿”å›çš„å€¼ sender WebContents - è¿”å›å‘é€æ¶ˆæ¯çš„ WebContents ports MessagePortMain[] - éšç€æ¶ˆæ¯ä¸€èµ·ä¼ é€çš„ MessagePort åˆ—è¡¨ reply Function - å°† IPC æ¶ˆæ¯å‘é€åˆ°æ¸²æŸ“å™¨æ¡†æ¶çš„å‡½æ•°ï¼Œè¯¥æ¸²æŸ“å™¨æ¡†æ¶å‘é€å½“å‰æ­£åœ¨å¤„ç†çš„åŸå§‹æ¶ˆæ¯ï¼Œä½ åº”è¯¥ä½¿ç”¨ reply æ–¹æ³•å›å¤å‘é€çš„æ¶ˆæ¯ï¼Œä»¥ç¡®ä¿å›å¤å°†è½¬åˆ°æ­£ç¡®çš„è¿›ç¨‹å’Œæ¡†æ¶ã€‚ channel String ...args any[] ipcRendererEvent å¯¹è±¡ç»§æ‰¿ Event frameID Integer - å‘é€è¯¥æ¶ˆæ¯çš„æ¸²æŸ“è¿›ç¨‹æ¡†æ¶çš„ ID WebContents - è¿”å›å‘é€æ¶ˆæ¯çš„ WebContents","link":"/2020/09/17/electron-ipcMain-md/"},{"title":"åµŒå¥—å‡½æ•°å’Œé—­åŒ…","text":"åœ¨ JS ä¸­ï¼Œå¯ä»¥åœ¨ä¸€ä¸ªå‡½æ•°ä¸­åµŒå¥—å¦ä¸€ä¸ªå‡½æ•°ï¼Œå†…éƒ¨å‡½æ•°å¯¹å¤–éƒ¨å‡½æ•°æ˜¯ç§æœ‰çš„ã€‚å®ƒè‡ªèº«ä¹Ÿå½¢æˆäº†ä¸€ä¸ªé—­åŒ…ï¼Œè¿™æ„å‘³ç€å®ƒè‡ªèº«å¯ä»¥æ‹¥æœ‰ç‹¬ç«‹çš„ç¯å¢ƒä¸å˜é‡è¡¨è¾¾å¼ã€‚ ä¸€ä¸ªåµŒå¥—ï¼ˆå†…éƒ¨ï¼‰å‡½æ•°å¯ä»¥â€œç»§æ‰¿â€å®¹å™¨ï¼ˆå¤–éƒ¨ï¼‰å‡½æ•°çš„å‚æ•°å’Œå˜é‡ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå†…éƒ¨å‡½æ•°åŒ…å«å¤–éƒ¨å‡½æ•°çš„ä½œç”¨åŸŸã€‚ å†…éƒ¨å‡½æ•°åªèƒ½åœ¨å¤–éƒ¨å‡½æ•°ä¸­è®¿é—® å†…éƒ¨å‡½æ•°å½¢æˆäº†ä¸€ä¸ªé—­åŒ…ï¼šä»–å¯ä»¥è®¿é—®å¤–éƒ¨å‡½æ•°çš„å‚æ•°å’Œå˜é‡ï¼Œä½†å¤–éƒ¨å‡½æ•°å´ä¸èƒ½ä½¿ç”¨å®ƒçš„å˜é‡å’Œå‚æ•°ã€‚ 123456789function addSquares(a, b) { function square(x) { return x * x; } return square(a) + square(b);}a = addSquares(2, 3); // returns 13b = addSquares(3, 4); // returns 25c = addSquares(4, 5); // returns 41 ç”±äºå†…éƒ¨å‡½æ•°å½¢æˆäº†é—­åŒ…ï¼Œå› æ­¤ä½ å¯ä»¥è°ƒç”¨å¤–éƒ¨å‡½æ•°å¹¶ä¸ºå¤–éƒ¨å‡½æ•°å’Œå†…éƒ¨å‡½æ•°æŒ‡å®šå‚æ•° 1234567891011121314function outside(x) { function inside(y) { return x + y; } return inside;}fn_inside = outside(3); // å¯ä»¥è¿™æ ·æƒ³ï¼šç»™ä¸€ä¸ªå‡½æ•°ï¼Œä½¿å®ƒçš„å€¼åŠ 3ï¼Œfn_inside æˆä¸ºäº†ä¸€ä¸ªå‡½æ•°console.log(fn_inside);result = fn_inside(5); // returns 8result1 = outside(3)(5); // returns 8console.log(result); ä¿å­˜å˜é‡ä¸€ä¸ªé—­åŒ…å¿…é¡»ä¿å­˜å®ƒå¯è§ä½œç”¨åŸŸä¸­æ‰€æœ‰å‚æ•°å’Œå˜é‡ã€‚å› ä¸ºæ¯ä¸€æ¬¡è°ƒç”¨ä¼ å…¥çš„å‚æ•°éƒ½å¯èƒ½ä¸åŒï¼Œæ¯ä¸€æ¬¡å¯¹å¤–éƒ¨å‡½æ•°çš„è°ƒç”¨å®é™…ä¸Šé‡æ–°åˆ›å»ºäº†ä¸€éè¿™ä¸ªé—­åŒ…ï¼Œåªæœ‰å½“è¿”å›çš„ inside æ²¡æœ‰å†æ¬¡è¢«å¼•ç”¨æ—¶ï¼Œå†…å­˜æ‰ä¼šé‡Šæ”¾ã€‚ å¤šå±‚åµŒå¥—å‡½æ•°å‡½æ•°å¯ä»¥è¢«å¤šå±‚åµŒå¥—ï¼Œå› æ­¤ï¼Œé—­åŒ…å¯ä»¥åŒ…å«å¤šä¸ªä½œç”¨åŸŸï¼›ä»–ä»¬é€’å½’å¼çš„åŒ…å«äº†æ‰€æœ‰åŒ…å«å®ƒçš„å‡½æ•°ä½œç”¨åŸŸï¼Œè¿™ä¸ªç§°ä¹‹ä¸ºä½œç”¨åŸŸé“¾ã€‚ 1234567891011121314function A(x) { function B(y) { console.log(111); function C(z) { console.log(x + y + z); } C(3); } console.log(333); B(2); console.log(222);}A(1); // logs 6 (1 + 2 + 3) è¾“å‡ºç»“æœï¼š 12343331116222 å‘½åå†²çªå½“åŒä¸€ä¸ªé—­åŒ…ä½œç”¨åŸŸä¸‹ä¸¤ä¸ªå‚æ•°æˆ–è€…å˜é‡åŒåæ—¶ï¼Œå°±ä¼šäº§ç”Ÿå‘½åå†²çªã€‚æ›´è¿‘çš„ä½œç”¨åŸŸæœ‰æ›´é«˜çš„ä¼˜å…ˆæƒï¼Œæ‰€ä»¥æœ€è¿‘çš„ä¼˜å…ˆçº§æœ€é«˜ï¼Œæœ€è¿œçš„ä¼˜å…ˆçº§æœ€ä½ã€‚è¿™å°±æ˜¯ä½œç”¨åŸŸé“¾ã€‚é“¾çš„ç¬¬ä¸€ä¸ªå…ƒç´ å°±æ˜¯æœ€é‡Œé¢çš„ä½œç”¨åŸŸï¼Œæœ€åä¸€ä¸ªå…ƒç´ ä¾¿æ˜¯æœ€å¤–å±‚çš„ä½œç”¨åŸŸã€‚ 123456789function outside() { var x = 5; function inside(x) { return x * 2; } return inside;}outside()(10); // returns 20 instead of 10 é—­åŒ…é—­åŒ…æ˜¯ JavaScript æœ€å¼ºå¤§çš„ç‰¹æ€§ä¹‹ä¸€ã€‚å½“å†…éƒ¨å‡½æ•°çš„ç”Ÿå­˜å‘¨æœŸå¤§äºå¤–éƒ¨å‡½æ•°æ—¶ï¼Œå¤–éƒ¨å‡½æ•°ä¸­çš„å®šä¹‰çš„å˜é‡å’Œå‡½æ•°çš„ç”Ÿå­˜å‘¨æœŸå°†æ¯”å†…éƒ¨å‡½æ•°æ‰§è¡Œæ—¶é—´é•¿ã€‚å½“å†…éƒ¨å‡½æ•°ä»¥æŸä¸€ç§æ–¹å¼è¢«ä»»ä½•ä¸€ä¸ªå¤–éƒ¨å‡½æ•°ä½œç”¨åŸŸè®¿é—®æ—¶ï¼Œä¸€ä¸ªé—­åŒ…å°±äº§ç”Ÿäº†ã€‚ 1234567891011var pet = function(name) { //å¤–éƒ¨å‡½æ•°å®šä¹‰äº†ä¸€ä¸ªå˜é‡\"name\" var getName = function() { //å†…éƒ¨å‡½æ•°å¯ä»¥è®¿é—® å¤–éƒ¨å‡½æ•°å®šä¹‰çš„\"name\" return name; } //è¿”å›è¿™ä¸ªå†…éƒ¨å‡½æ•°ï¼Œä»è€Œå°†å…¶æš´éœ²åœ¨å¤–éƒ¨å‡½æ•°ä½œç”¨åŸŸ return getName; };myPet = pet(\"Vivie\"); myPet(); // è¿”å›ç»“æœ \"Vivie\" ä½¿ç”¨ arguments å¯¹è±¡å‡½æ•°çš„å®é™…å‚æ•°ä¼šè¢«ä¿å­˜åœ¨ä¸€ä¸ªç±»ä¼¼æ•°ç»„çš„ arguments å¯¹è±¡ä¸­ã€‚ ä½¿ç”¨ arguments å¯¹è±¡ï¼Œä½ å¯ä»¥å¤„ç†æ¯”å£°æ˜çš„æ›´å¤šçš„å‚æ•°æ¥è°ƒç”¨å‡½æ•°ã€‚è¿™åœ¨ä½ äº‹å…ˆä¸çŸ¥é“ä¼šéœ€è¦å°†å¤šå°‘å‚æ•°ä¼ é€’ç»™å‡½æ•°æ—¶ååˆ†æœ‰ç”¨ã€‚ ä¾‹å¦‚ä¸‹é¢è¿™ä¸ªé“¾æ¥å­—ç¬¦ä¸²çš„å‡½æ•° 1234567891011function myConcat(separator) { var result = ''; // æŠŠå€¼åˆå§‹åŒ–æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨æ¥ä¿å­˜å­—ç¬¦ä¸²äº†ï¼ï¼ var i; // iterate through arguments for (i = 1; i < arguments.length; i++) { result += arguments[i] + separator; } return result;}// returns \"red, orange, blue, \"myConcat(\", \", \"red\", \"orange\", \"blue\"); å‡½æ•°å‚æ•°é»˜è®¤å‚æ•°åœ¨ JavaScript ä¸­ï¼Œå‡½æ•°å‚æ•°çš„é»˜è®¤å€¼æ˜¯ undefinedã€‚ å‰©ä½™å‚æ•°å‰©ä½™å‚æ•°è¯­æ³•å…è®¸å°†ä¸ç¡®å®šçš„å‚æ•°è¡¨ç¤ºä¸ºæ•°ç»„ 123456function multiply(multiplier, ...theArgs) { return theArgs.map(x => multiplier * x);}var arr = multiply(2, 1, 2, 3);console.log(arr); // [2, 4, 6]","link":"/2020/09/15/%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/"},{"title":"æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…","text":"é¢˜æ„ï¼šç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªå­—ç¬¦è§„å¾‹ pï¼Œè¯·ä½ å®ç°ä¸€ä¸ªæ”¯æŒ '.' å’Œ '*' çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€‚12'.' åŒ¹é…ä»»æ„å•ä¸ªå­—ç¬¦'*' åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰é¢çš„é‚£ä¸€ä¸ªå…ƒç´  æ‰€è°“åŒ¹é…ï¼Œæ˜¯è¦æ¶µç›–æ•´ä¸ªå­—ç¬¦ä¸² s çš„ï¼Œè€Œä¸æ˜¯éƒ¨åˆ†å­—ç¬¦ä¸²ã€‚ æ ·ä¾‹ï¼š 12345è¾“å…¥ï¼šs = \"aab\"p = \"c*a*b\"è¾“å‡º ï¼štrueè§£é‡Š ï¼š å› ä¸º '*' è¡¨ç¤ºé›¶ä¸ªæˆ–å¤šä¸ªï¼Œè¿™é‡Œ 'c' ä¸º 0 ä¸ª, 'a' è¢«é‡å¤ä¸€æ¬¡ã€‚å› æ­¤å¯ä»¥åŒ¹é…å­—ç¬¦ä¸² \"aab\"ã€‚ æ€è·¯ï¼šå¾ˆæ˜æ˜¾è¿™é“é¢˜å±äºåŠ¨å½’å§ï¼ŸçŠ¶æ€å…¶å®å¾ˆå¥½è¡¨ç¤ºï¼šdp[i][j] è¡¨ç¤º s çš„å‰ i ä¸ªå­—ç¬¦å’Œ p çš„å‰ j ä¸ªå­—ç¬¦çš„åŒ¹é…æƒ…å†µï¼Œè½¬ç§»æ–¹ç¨‹çš„å…³é”®åœ¨äº s[i] å’Œ p[j]ã€‚å°¤å…¶è¦æ³¨æ„ . å’Œ * å­—ç¬¦ã€‚ å½“ s[i] == p[j] || p[j] == '.' æ—¶ï¼Œdp[i][j] = dp[i-1][j-1ï¼› å½“ p[j] == '* æ—¶ï¼Œæƒ…å†µå°±æ˜¾å¾—æ¯”è¾ƒå¤æ‚äº†: å½“ s[i] != p[j-1] && p[j-1] != '. æ—¶ï¼Œæ„å‘³ç€ s çš„å‰ i ä¸ªå­—ç¬¦ä¸ p çš„å‰ j å’Œå‰ j-1 ä¸ªå­—ç¬¦éƒ½æ˜¯ä¸èƒ½åŒ¹é…çš„ï¼ˆå› ä¸ºæœ«å°¾ä¸ç›¸ç­‰ï¼‰ï¼Œæ‰€ä»¥ dp[i][j] = dp[i][j-2]ï¼› å¦åˆ™ï¼Œå°±æŠŠæœ€åçš„ p[j-1],p[j] æ¥è¿›è¡Œåˆ†ç±»è®¨è®ºï¼Œç”±äº * ä»£è¡¨é‡å¤ $0$ åˆ°å¤šæ¬¡ï¼Œæ‰€ä»¥è¿™æ—¶å€™å°±å¾ˆæ˜æ˜¾äº†ï¼Œè¦ä¹ˆ $0$ï¼Œæ¬¡ï¼Œè¦ä¹ˆå¤šæ¬¡ï¼›$0$ æ¬¡çš„æ—¶å€™ï¼šdp[i][j] = dp[i][j-2]ï¼Œå¤šæ¬¡çš„æ—¶å€™ï¼šdp[i][j] = dp[i-1][j]ã€‚è¿™äºŒè€…æ˜¯æˆ–çš„å…³ç³»ã€‚ æ³¨æ„ï¼š ç©ºä¸²çš„æƒ…å†µã€‚ åˆå§‹åŒ– dp[0][0] = 1ã€‚ è§£å†³ç©ºä¸²æ¯”è¾ƒå¥½çš„ä¸€ä¸ªæ–¹æ³•æ˜¯åœ¨ s å’Œ p å‰éƒ½åŠ ä¸€ä¸ª \"\"ã€‚ ä»£ç ï¼š1234567891011121314151617181920class Solution {public: bool isMatch(string s, string p) { s = \" \"+s; p = \" \"+p; int n = s.size(), m = p.size(); int dp[n+1][m+1]; memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for(int i = 1; i","link":"/2020/10/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"title":"æš‘æœŸè‡ªè®­ $1$","text":"$A.\\ CF1236A$çº¯ç­¾ $B.\\ CF1236B$é¢˜æ„ï¼šæœ‰ $n$ ç§ç¤¼ç‰©ï¼Œæ¯ç§ç¤¼ç‰©æ•°é‡æ— é™ã€‚$m$ ä¸ªå¯åŒºåˆ†ç›’å­ã€‚è‡³å°‘æœ‰ä¸€ä¸ªç›’å­æœ‰ç¤¼ç‰©ä¸”æ¯ç§ç¤¼ç‰©æœ€å°‘éƒ½è¦æ”¾ä¸€ä¸ªã€‚é—®æœ‰å¤šå°‘ç§æ–¹æ³•ã€‚ æ€è·¯ï¼šå¯¹æ¯ç§ç¤¼ç‰©è¿›è¡Œè€ƒè™‘ï¼Œç›’å­æœ‰è¯¥ç¤¼ç‰©å’Œæ²¡è¯¥ç¤¼ç‰©ä¸¤ç§çŠ¶æ€ï¼Œè¿™æ ·æ¯ä¸ªç›’å­éƒ½èƒ½ç”¨ $0$ å’Œ $1$ æ¥è¡¨ç¤ºä¸¤ç§çŠ¶æ€ã€‚å› ä¸ºä¸èƒ½å…¨ç©ºï¼Œè¿™ä¸ªæ—¶å€™å°±æœ‰ $2^m-1$ ç§æƒ…å†µï¼›å†æ¥è€ƒè™‘æ”¾ç¤¼ç‰©ã€‚ä¸éš¾å‘ç°ï¼Œå¯¹äºæ¯ä¸ªç›’å­æ¥è¯´ï¼Œå¯ä»¥è£…è¿™ä¸ªç¤¼ç‰©ä¹Ÿå¯ä»¥ä¸è£…ï¼Œæ‰€ä»¥ç­”æ¡ˆå°±æ˜¯ $(2^m-1)^n$ 123456789101112131415161718192021222324252627282930313233343536#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i >= 1; a *= a, a %= mod; } return ans;}int main(){ cin >> n >> m; LL ans = qpow(qpow(2, m) - 1, n); cout < ans < n; int ans[maxn][maxn]; int m = n, cnt = 0; for(int i = 0; i < n; ++i) { if(i % 2 == 0) { for(int j = 0; j < n; ++j) ans[j][i] = ++cnt; } else for(int j = n - 1; j >= 0; --j) ans[j][i] = ++cnt; } for(int i = 0; i < n; ++i) for(int j = 0; j < n; ++j) printf(\"%d%c\", ans[i][j], (j == n - 1) ? '\\n' : ' '); return 0;} $G\\ CF1244A$çº¯ç­¾ $H\\ CF1244B$é¢˜æ„ï¼šä¸¤å±‚è¿·å®«ï¼Œå¹³è¡Œä½ç½®å¯ä»¥äº’ç›¸æ¥å¾€ï¼Œå½“è¯¥ä½ç½®ä¸º $1$ æ—¶ï¼Œå¯ä»¥ä¸Šä¸‹è¡Œèµ°ï¼Œæ¯ä¸ªæ ¼å­æœ€å¤šèµ°ä¸€æ¬¡ã€‚é—®èƒ½èµ°æœ€å¤šçš„æ ¼å­çš„æ•°é‡ã€‚ æ€è·¯ï¼šå½“ $s[0]=â€™1â€™$ æˆ–è€… $s[n-1]=â€™1â€™$ æ—¶ï¼Œå¯ä»¥èµ°å®Œæ‰€æœ‰çš„æ ¼å­ï¼Œè¿›è€Œç»§ç»­æ¨å¯¼ï¼Œèƒ½èµ°å¤šå°‘ä¸ªæ ¼å­å–å†³äºçš„ä¸¤ç«¯çš„ $1$ çš„ä½ç½®ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { cin >> n; cin >> s; int ans = 0; int flag = 0; vector v; for(int i = 0; i < n; ++i) if(s[i] == '1') v.push_back(i); if(!v.size()) ans = n; else { ans = max(2 * (v[0] + 1), 2 * (v.back() + 1)); ans = max(ans, 2 * (n - v[0])); ans = max(ans, 2 * (n - v.back())); } cout < ans < x >> y; d[x]++; d[y]++; if(d[x] > 2) flag = false; if(d[y] > 2) flag = false; v[x].pb(y); v[y].pb(x); } if(!flag) { puts(\"-1\"); return 0; } for(int i = 1; i","link":"/2020/06/25/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD1/"},{"title":"æš‘æœŸè‡ªè®­2","text":"$A.\\ CF1277C$é¢˜æ„ï¼šç»™ä½ ä¸€ä¸²æ‹¬å·åºåˆ—ï¼Œä½ å¯ä»¥é€‰æ‹©ä»»æ„ä¸€ç«¯åŒºé—´è¿›è¡Œå€’ç½®ã€‚è¦å°†å…¶å˜ä¸ºæ­£åˆ™çš„ï¼Œå¹¶ä¸”å‰ç¼€ä¸­æœ‰ $k$ ä¸ªæ­£åˆ™çš„ï¼Œç»™å‡ºå˜æ¢åºåˆ—ã€‚ æ€è·¯ï¼šå…ˆå˜ä¸º $()()\\cdots()$ å½¢å¼ï¼Œç„¶åä»å‰å¾€åè¿›è¡Œåˆå¹¶ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { vector ans; scanf(\"%d%d\", &n, &k); cin >> s; for(int i = 0; i < n - 1; i += 2) { if(s[i] == '(' && s[i + 1] == ')') continue; else if(s[i] == '(' && s[i + 1] != ')') { int j = i + 2; while(j < n && s[j] == '(') ++j; reverse(s + i + 1, s + j + 1); ans.pb(mk(i + 1, j)); } else if(s[i] != '(') { int j = i + 1; while(j < n && s[j] == ')') ++j; reverse(s + i, s + j + 1); ans.pb(mk(i, j)); } } int x = n / 2 - k; int i = 1, cnt = 1; while(x--) { ans.pb(mk(i, i + cnt)); i++; cnt++; } cout < ans.size() <","link":"/2020/06/29/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD2/"},{"title":"æ­£ç¡®é…ç½®hexoç¯å¢ƒå˜é‡","text":"æœ€è¿‘åœ¨ $windows$ ä¸Šæ­å»ºäº† $Hexo$ åšå®¢ï¼Œå‡ºå¸ˆæœªæ·èº«å…ˆæ­»å§ï¼Œåœ¨é…ç½®ç¯å¢ƒå˜é‡çš„æ—¶å€™æ€»æ˜¯å‡ºé—®é¢˜ï¼Œçœ‹äº†å¥½å‡ ç¯‡åˆ«äººçš„åšå®¢ä¹Ÿæ— æµäºäº‹ã€‚æœ€åæˆ‘æƒ³ï¼Œè¦ä½¿ç”¨ $Hexo$ æŒ‡ä»¤ï¼Œåº”è¯¥æ˜¯å°†ä¸€ä¸ªå¸¦æœ‰ $.exe$ åç¼€çš„æ–‡ä»¶è·¯å¾„åŠ å…¥åˆ° $Path$ ä¸­ï¼Œäºæ˜¯æˆ‘ä½¿ç”¨ä¸‡èƒ½çš„ $Everything$ æœç´¢äº† $hexo$ï¼Œäºæ˜¯æ‰¾åˆ°äº† $hexo.cmd$$Windows$ ç”¨æˆ·åº”è¯¥åªè¦å°†è¿™ä¸ªè·¯å¾„åŠ å…¥åˆ°ç³»ç»Ÿå˜é‡ä¸­çš„ $Path$ å³å¯æ­£å¸¸ä½¿ç”¨äº†ã€‚","link":"/2020/06/17/%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEhexo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"title":"ç‰›å®¢å¤šæ ¡02","text":"$F\\ Fake\\ Maxpooling(äºŒç»´å•è°ƒé˜Ÿåˆ—)$é¢˜æ„ï¼šç»™ä½ ä¸€ä¸ª $nm$ çš„æ•°ç»„ï¼Œæ•°ç»„ä¸­çš„å…ƒç´ ä¸º $a_{i,j}=lcm(i,j)$ï¼Œå†ç»™ä½ ä¸€ä¸ªæ•°å­— $k$ï¼Œæ±‚å‡ºå­çŸ©é˜µå¤§å°ä¸º $kk$ çš„æœ€å¤§å€¼çš„å’Œã€‚ æ€è·¯ï¼šè¿™é‡Œä»‹ç»ä¸€ä¸‹å•è°ƒé˜Ÿåˆ—ã€‚å•è°ƒé˜Ÿåˆ—ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯ä¸€ç§å…·æœ‰å•è°ƒæ€§çš„é˜Ÿåˆ—ï¼Œä¸€ç§é€’å¢ï¼Œå¦ä¸€ç§é€’å‡ã€‚ç”¨å•è°ƒé˜Ÿåˆ—æ¥è§£å†³é—®é¢˜ï¼Œä¸€èˆ¬éƒ½æ˜¯éœ€è¦å¾—åˆ°å½“å‰åŒºé—´çš„æœ€å°å€¼æˆ–è€…æœ€å¤§å€¼ã€‚ æˆ‘ä»¬å…ˆè€ƒè™‘ä¸€ç»´çš„æƒ…å†µï¼Œå¾—åˆ°åŒºé—´é•¿åº¦ä¸º $k$ çš„æœ€å¤§å€¼ã€‚ ä¸¾ä¸ªä¾‹å­ï¼šæœ‰ $7,6,8,12,9,10,3$ ä¸ƒä¸ªæ•°å­—ï¼Œç°åœ¨è®©ä½ æ‰¾å‡ºèŒƒå›´ $(i-4,i]$ çš„æœ€å°å€¼ã€‚æ¥ä¸‹æ¥æ˜¯æ¨¡æ‹Ÿè¿‡ç¨‹ï¼š åˆå§‹åŒ–ä¸º ${0}$ã€‚ $i=1\\rightarrow{7}$$i=2\\rightarrow{6}$$i=3\\rightarrow{6,8}$$i=4\\rightarrow{6,8,12}$$i=5\\rightarrow{6,8,9}$$i=6$ æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  $6$ ä¸åœ¨èŒƒå›´ $(2,6]$ ä¸­ï¼Œæ•…å°† $6$ å¼¹å‡º $\\rightarrow{8,9,10}$$i=7\\rightarrow{3}$ æˆ‘ä»¬æ¥çœ‹ä¸€é“ä¾‹é¢˜ï¼šæ´›è°· $p1866$ é¢˜ç›®æè¿°ï¼šæœ‰ä¸€ä¸ªé•¿ä¸º $n$ çš„åºåˆ— $a$ï¼Œä»¥åŠä¸€ä¸ªå¤§å°ä¸º $k$ çš„çª—å£ã€‚ç°åœ¨è¿™ä¸ªä»å·¦è¾¹å¼€å§‹å‘å³æ»‘åŠ¨ï¼Œæ¯æ¬¡æ»‘åŠ¨ä¸€ä¸ªå•ä½ï¼Œæ±‚å‡ºæ¯æ¬¡æ»‘åŠ¨åçª—å£ä¸­çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ã€‚æˆ‘ä»¬ç›´æ¥å¥—æ¨¡æ¿è§£å†³è¿™é“é¢˜å§ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include #include #include #define pii pairusing namespace std;int n, k;int a[1000007];deque que_max;deque que_min;vector ans_max, ans_min;int main(){ scanf(\"%d%d\", &n, &k); for(int i = 1; i","link":"/2020/07/21/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A102/"},{"title":"ç‰›å®¢å¤šæ ¡03","text":"$G\\ Operating\\ on\\ a\\ Graph$é¢˜æ„ï¼šç»™å®šä¸€ä¸ªå›¾ï¼Œ$q$ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ä¸ºä¸€ä¸ªé¢œè‰² $o$ï¼Œè‹¥è¯¥å›¾ä¸Šå­˜åœ¨é¢œè‰²ä¸º $o$ çš„éƒ¨åˆ†ï¼Œåˆ™å°†ä¸è¯¥éƒ¨åˆ†ç›¸é‚»çš„ç‚¹æ¶‚æˆé¢œè‰² $o$ï¼Œé—®æœ€åæ¯ä¸ªç‚¹æ˜¯ä»€ä¹ˆé¢œè‰²ã€‚ æ€è·¯ï¼šé¦–å…ˆå®¹æ˜“æƒ³åˆ°ï¼Œè¿™ä¸ªé¢˜åº”è¯¥å¯ä»¥ç”¨å¹¶æŸ¥é›†æ¥ç»´æŠ¤é¢œè‰²ä¿¡æ¯ã€‚å¾ˆç›´è§‚çš„åšæ³•æ˜¯æˆ‘ä»¬æŠŠè¯¥éƒ¨åˆ†ç›¸è¿çš„æ¯ä¸€ä¸ªç‚¹éƒ½æ›´æ”¹é¢œè‰²ï¼Œä½†è¿™æ ·å¾ˆæ˜¾ç„¶ä¼šè¶…æ—¶ã€‚æˆ‘ä»¬ç”¨ $vector[i]$ æ¥ç»´æŠ¤ä¸ $i$ ç›¸é‚»çš„ç‚¹ï¼Œæ¯æ¬¡è¯¢é—®æ—¶ï¼Œéå†æ‰€æœ‰ä¸è¯¥éƒ¨åˆ†ç›¸é‚»çš„ç‚¹ï¼ˆå¦‚æœå±äºå°±ç›´æ¥è·³è¿‡ï¼‰ï¼Œå°†æ‰€æœ‰å±äºè¯¥ç‚¹ç¥–å…ˆçš„è¾¹å†…æ‰€æœ‰ç‚¹ç‚¹æ”¾å…¥é¢œè‰² $o$ ä¸­ã€‚åˆå¹¶çš„æ—¶å€™è¦ç”¨åˆ°å¯å‘å¼åˆå¹¶ï¼Œå°†å°é›†åˆåˆå¹¶åˆ°å¤§é›†åˆå½“ä¸­å»ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define ArrayDebug(a, l, r) for(int i = l; i","link":"/2020/07/21/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A103/"},{"title":"Gotw1","text":"C++ æœ‰å¤šå°‘ç§åˆå§‹åŒ–å˜é‡çš„æ–¹æ³•å››ç§ï¼š é»˜è®¤åˆå§‹åŒ– ç›´æ¥åˆå§‹åŒ– æ‹·è´åˆå§‹åŒ– åˆ—è¡¨åˆå§‹åŒ– è¯´ä¸‹ä¸‹é¢å„è¡Œä»£ç çš„å«ä¹‰123456789widget w; // (a)widget w(); // (b)widget w{}; // (c)widget w(x); // (d)widget w{x}; // (e)widget w = x; // (f)widget w = {x}; // (g)auto w = x; // (h)auto w = widget{x}; // (i) (a) æ˜¯é»˜è®¤åˆå§‹åŒ–ï¼Œè°ƒç”¨çš„æ˜¯ default constructor widget::widget()(b) æ˜¯ä¸ªé™·é˜±ï¼Œä¸æ˜¯å˜é‡åˆå§‹åŒ–ï¼Œè€Œæ˜¯ä¸€ä¸ªåä¸º w è¿”å› widget ç±»å‹ä¸”ä¸æ¥å—å‚æ•°çš„å‡½æ•°çš„å£°æ˜ï¼Œä»¤äººè®¨åŒçš„äº‹ï¼Œè¿™ç§å½¢å¼å¾ˆæœ‰å¯èƒ½å½¢æˆæ­§ä¹‰ï¼Œä¾‹å¦‚ä¸‹é¢çš„ä»£ç ï¼š 123// same problem (gadget and doodad are types)//widget w( gadget(), doodad() ); // pitfall: not a variable declaration å¥½æ¶ˆæ¯æ˜¯ C++11 è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œé€šè¿‡æä¾›ä¸€ç§å‡ ä¹åœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½å–ä»£ case (b) çš„è¯­æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸å¿…å†é™·å…¥è¿™ä¸ªå‘äº†ï¼Œç­”æ¡ˆå°±æ˜¯ case (c)(c) æ˜¯ä¸€ç§éå¸¸å¥½çš„å†™æ³•ï¼Œå®ƒæ€»æ˜¯åˆå§‹åŒ–å˜é‡ï¼Œå¹¶ä¸”æ°¸è¿œä¸ä¼šä¸å‡½æ•°å£°æ˜äº§ç”Ÿæ­§ä¹‰ã€‚(d) å’Œ (e) éƒ½æ˜¯ç›´æ¥åˆå§‹åŒ–ï¼ˆå‡è®¾ x ä¸æ˜¯ç±»å‹åï¼‰ã€‚äºŒè€…éƒ½æ˜¯é€šè¿‡ widget::widget(x)ã€‚å¦‚æœ x æ˜¯ widget ç±»å‹ï¼Œåˆ™è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ï¼Œå¦åˆ™ï¼Œå°†è°ƒç”¨è½¬æ¢æ„é€ å‡½æ•°ï¼Œæ³¨æ„åˆ° (e) åˆ›å»ºäº†ä¸€ä¸ª std::initializer_listã€‚å¦‚æœ widget æœ‰ä¸€ä¸ªå¸¦ initializer_list çš„æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ„é€ å‡½æ•°æ˜¯é¦–é€‰ï¼› å¦åˆ™ï¼Œå¦‚æœ widget å…·æœ‰æ¥å—ä»»ä½•ç±»å‹ x çš„æ„é€ å‡½æ•°ï¼ˆå¯èƒ½å¸¦æœ‰è½¬æ¢ï¼‰ï¼Œåˆ™ä½¿ç”¨è¯¥æ„é€ å‡½æ•°ã€‚ä½¿ç”¨ (e) æœ‰ä»¥ä¸‹å‡ ä¸ªå¥½å¤„ï¼ˆç›¸è¾ƒäº (d)ï¼‰ï¼š é¿å…äº†æ­§ä¹‰ï¼Œå› ä¸º (e) æ°¸è¿œä¸å¯èƒ½æ˜¯æ˜¯ä¸€ä¸ªå‡½æ•°å£°æ˜ æ›´å®‰å…¨ï¼Œå› ä¸º (e) ä¸å…è®¸æœ‰æŸè½¬æ¢ 12int i1( 12.345 ); // ok: toss .345, we didn't like it anywayint i2{ 12.345 }; // error: would be lossy implicit narrowing (f) å’Œ (g) åˆ†åˆ«æ˜¯å¤åˆ¶åˆå§‹åŒ–å’Œå¤åˆ¶åˆ—è¡¨åˆå§‹åŒ–åœ¨ (f) ä¸­ï¼Œä»æ¦‚å¿µä¸Šæ¥è®²ï¼Œw åº”è¯¥æ˜¯é€šè¿‡æ‹·è´æ„é€ å‡½æ•°æˆ–è€…ç§»åŠ¨æ„é€ å‡½æ•°åˆå§‹åŒ–çš„ï¼Œä½†å¿…é¡»çº æ­£çš„ä¸€ç‚¹æ˜¯ï¼Œä¸æ˜¯å‡ºç°çš„ = å°±æ„å‘³ç€è°ƒç”¨çš„ T::operator=ï¼Œå®ƒä»ç„¶æ˜¯å±äºåˆå§‹åŒ–è€Œä¸æ˜¯èµ‹å€¼ã€‚å¦‚æœ x æ˜¯ widget ç±»å‹çš„ï¼Œé‚£ä¹ˆ (f) å’Œ (d) æ˜¯ä¸€æ ·çš„ï¼Œè°ƒç”¨ widget::widget(x);ï¼ˆé™¤äº† explicit ctor è¢«è°ƒç”¨ï¼‰ï¼›å¦‚æœ x æ˜¯å…¶å®ƒç±»å‹ï¼Œä»æ¦‚å¿µä¸Šè®²ï¼Œç¼–è¯‘å™¨é¦–å…ˆå°† x éšå¼è½¬æ¢ä¸ºä¸´æ—¶ widget å¯¹è±¡ï¼Œç„¶åä»è¯¥ä¸´æ—¶å³å€¼ç§»åŠ¨æ„é€  wï¼Œå¦‚æœæ²¡æœ‰æ›´å¥½çš„ç§»åŠ¨æ„é€ å‡½æ•°ï¼Œåˆ™ä½¿ç”¨å¤åˆ¶æ„é€ ä½œä¸ºâ€œç§»åŠ¨çš„ç¼“æ…¢æ–¹å¼â€ä½œä¸ºå¤‡ä»½å¯ç”¨ã€‚å‡è®¾éšå¼è½¬æ¢å¯ç”¨ï¼Œ(f) çš„æ„æ€ä¸ widget w(widget(x)); ç›¸åŒã€‚(g) è¢«ç§°ä¹‹ä¸º copy-list-initializationï¼Œå«ä¹‰å’Œ widget w{x} ç›¸åŒï¼Œä½†æ³¨æ„ï¼Œcopy-list-initialization ä¸ä¼šè°ƒç”¨ explicit ctorï¼Œåªæœ‰æ™®é€šçš„æ„é€ å‡½æ•°æ‰èƒ½è¢«è°ƒç”¨(h) å’Œ (i) éƒ½æ˜¯å¤åˆ¶åˆå§‹åŒ–ï¼Œä»–ä»¬çš„è¯­ä¹‰å’Œ (f) å’Œ (g) ç›¸ä¼¼ï¼Œä½†æ›´åŠ ç®€å•ï¼Œå› ä¸º auto ä¿è¯äº†å³æ‰‹è¡¨è¾¾å¼çš„ç±»å‹å°†è¢«å‡†ç¡®æ¨å¯¼å‡ºLine (h) means the same as (d), type_of_x w(x);. Only a single copy constructor is called. This is guaranteed to stay true as the program evolves: Because line (h) does not commit to an explicit type, it is guaranteed to be both maximally efficient because there can be no conversion involved, and maximally robust under maintenance as the type of w â€œautoâ€-matically tracks the type of x which may change as the program is maintained. Line (i) is the most consistent spelling when you do want to commit to a specific type and explicitly request a conversion if needed, and once again the { } syntax happily avoids lossy narrowing conversions. In practice on most compilers, only a single constructor is calledâ€”similarly to what we saw with (f) and (g), conceptually there are two constructor calls, a converting or copy constructor to create a temporary widget{x} followed by a move to move it to w, but compilers routinely elide the latter. è¿™ä¸¤æ®µè¯æ¥è‡ª https://herbsutter.com/2013/05/09/gotw-1-solution/ï¼Œç¿»è¯‘èµ·æ¥å¾ˆç´¯ã€‚ã€‚ã€‚","link":"/2021/11/21/Gotw1/"},{"title":"Redisæ•°æ®ç±»å‹ï¼šmap","text":"Redis ä¸­çš„å“ˆå¸Œè¡¨æ¯«æ— ç–‘é—®ï¼Œå“ˆå¸Œè¡¨æ˜¯ä¸€ç§éå¸¸é‡è¦çš„æ•°æ®ç»“æ„ï¼Œåœ¨åšç®—æ³•é¢˜æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿç»å¸¸ç”¨åˆ°å®ƒæ¥å®ç°å¸¸æ•°çº§åˆ«çš„è®¿é—®ï¼Œè€Œ Redis ä½œä¸ºä¸€ç§ Key-Value çš„å†…å­˜æ•°æ®åº“ï¼Œå½“ç„¶å°‘ä¸äº†å“ˆå¸Œè¡¨çš„å®ç°äº†ã€‚ åŸºæœ¬ç»“æ„åœ¨ Redis ä¸­ï¼Œå“ˆå¸Œè¡¨æ˜¯åŸºäºé“¾è¡¨å®ç°çš„ï¼Œé¦–å…ˆçœ‹å®ƒåœ¨ src/dic.h ä¸­å®šä¹‰çš„é“¾è¡¨çš„èŠ‚ç‚¹ç»“æ„ï¼š 12345678910typedef struct dictEntry { void * key; union { void * val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry * next;} dictEntry; æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œvalue éƒ¨åˆ†æ˜¯ä½¿ç”¨ä¸€ä¸ª union æ¥è¡¨ç¤ºçš„ï¼ŒæŸ¥çœ‹ union å…·ä½“å†…å®¹å¯ä»¥çœ‹åˆ°ï¼Œvalue ç±»å‹å¯ä»¥æ˜¯ä¸€ä¸ª 64 ä½æ•´æ•°ã€åŒç²¾åº¦æµ®ç‚¹æ•°æˆ–è€…ä¸€æ®µå†…å­˜ã€‚ ç„¶åæˆ‘ä»¬æ¥çœ‹å“ˆå¸Œè¡¨çš„ç»“æ„ï¼š 123456typedef struct dictht { dictEntry ** table; // table æ˜¯ä¸€ä¸ªæ•°ç»„ç»“æ„ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª dictEntry æŒ‡é’ˆ unsigned long size; // å“ˆå¸Œæ¡¶çš„æ•°é‡ unsigned long sizemask; // æ¡¶æ•°é‡çš„æ©ç  unsigned long used; // å·²ç»ä½¿ç”¨çš„æ•°é‡} dictht; ä¸Šè¿‡ç®—æ³•ä¸æ•°æ®ç»“æ„çš„å°ä¼™ä¼´æƒ³å¿…ä¹Ÿå¾ˆæ¸…æ¥šï¼Œå°±åƒåœ¨ä¸€ä¸ªæ•°ç»„ï¼ˆé“¾è¡¨ï¼‰ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹åˆå•ç‹¬æ˜¯ä¸€æ¡é“¾è¡¨ï¼Œå°±åƒä¸‹é¢è¿™æ ·ï¼š å›¾æºï¼š å…¶ä¸­çš„æ©ç ä¸»è¦æ˜¯ä¸ºäº†å®ç°å¿«é€Ÿå–ä½™çš„ç”¨é€”ï¼Œå®ƒçš„å¤§å°ä¸º size-1ï¼Œåœ¨ Redis ä¸­ï¼Œæ¡¶çš„æ•°é‡ä¸€å®šæ˜¯ $2^n$ ä¸ªï¼Œé‚£ä¹ˆç»™å®šä¸€ä¸ªå“ˆå¸Œå€¼ $hash$ å¯ä»¥ä½¿ç”¨ $hash & sizemask$ æ¥å¾—åˆ°è¯¥æ•°æ®è½åœ¨å“ªä¸€ä¸ªå“ˆå¸Œæ¡¶ä¸­ã€‚ æ¥ä¸‹æ¥æ¥çœ‹çœ‹å­—å…¸ç±»å‹ç‰¹å®šå‡½æ•°ï¼Œåœ¨ src/dic.h ä¸­ï¼Œå®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“ï¼Œé‡Œé¢å­˜å‚¨ç€ä¸€ç³»åˆ—å‡½æ•°æŒ‡é’ˆï¼Œè¿™äº›å¯¹åº”äº†åŸºç¡€çš„å“ˆå¸Œæ“ä½œï¼Œçœ‹åšå®¢è¯´è¿™æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„æ€æƒ³ï¼Œç„¶è€Œæˆ‘å¹¶æ²¡æœ‰ä¸Šè¿‡è¿™è¯¾ã€‚ã€‚ã€‚ 12345678typedef struct dictType { uint64_t (*hashFunction)(const void *key); //é€šç»™å¯å®škeyï¼Œè®¡ç®—å¯¹åº”çš„å“ˆå¸Œå€¼ void *(*keyDup)(void *privdata, const void *key); //ç”¨äºå¤åˆ¶keyçš„å‡½æ•°æŒ‡é’ˆ void *(*valDup)(void *privdata, const void *obj); //ç”¨äºå¤åˆ¶valueçš„å‡½æ•°æŒ‡é’ˆ int (*keyCompare)(void *privdata, const void *key1, const void *key2); //ä¸¤ä¸ªkeyçš„æ¯”è¾ƒå‡½æ•° void (*keyDestructor)(void *privdata, void *key); //ç”¨äºå¤„ç†keyçš„é‡Šæ”¾ void (*valDestructor)(void *privdata, void *obj); //ç”¨äºå¤„ç†valçš„é‡Šæ”¾} dictType; åœ¨ src/server.c ä¸­ï¼ŒRedis ä¸ºä¸åŒç±»å‹çš„å“ˆå¸Œè¡¨ç»™å‡ºäº†ä¸åŒçš„ dictTypeï¼Œä¾‹å¦‚ï¼š 123456789/* Db->dict, keyæ˜¯sdsåŠ¨æ€å­—ç¬¦ä¸², valsåˆ™æ˜¯Rediså¯¹è±¡ç±»å‹ */dictType dbDictType = { dictSdsHash, /* hash function */ NULL, /* key dup */ NULL, /* val dup */ dictSdsKeyCompare, /* key compare */ dictSdsDestructor, /* key destructor */ dictObjectDestructor /* val destructor */}; æœ‰äº† dictht å’Œ dictTypeï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šæœ€ç»ˆçš„å­—å…¸ç»“æ„äº†ï¼š 1234567typedef struct dict { dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */} dict; å­—å…¸åœ¨å†…å­˜ä¸­çš„ç»“æ„å¦‚ä¸‹ï¼š å›¾æºï¼š åœ¨ Redis ä¸­ï¼Œæ¯ä¸€ä¸ªå­—å…¸æœ‰ä¸¤ä¸ª dicthtï¼Œè¿™æ˜¯ä¸ºäº†å®ç° æ¸è¿›å¼ rehash è¿™ä¸ªæ¦‚å¿µæˆ‘ä¹Ÿä¸æ˜ç™½ï¼Œçœ‹çœ‹ã€ŠRedis è®¾è®¡ä¸å®ç°ã€‹çš„è¯´æ³•å§ï¼š rehashéšç€æ“ä½œçš„ä¸æ–­æ‰§è¡Œï¼Œå“ˆå¸Œè¡¨ä¿å­˜çš„é”®å€¼å¯¹ä¼šé€æ¸åœ°å¢å¤šæˆ–å‡å°‘ï¼Œä¸ºäº†è®©å“ˆå¸Œè¡¨çš„è´Ÿè½½å› å­ç»´æŒåœ¨ä¸€ä¸ªåˆç†çš„èŒƒå›´ä¹‹å†…ï¼Œå½“å“ˆå¸Œè¡¨ä¿å­˜çš„é”®å€¼å¯¹æ•°é‡å¤ªå¤šæˆ–å¤ªå°‘æ—¶ï¼Œç¨‹åºéœ€è¦å¯¹å“ˆå¸Œè¡¨çš„å¤§å°è¿›è¡Œç›¸åº”çš„æ‰©å±•æˆ–è€…æ”¶ç¼©ã€‚ Redis å¯¹å­—å…¸çš„å“ˆå¸Œè¡¨æ‰§è¡Œ rehash çš„æ­¥éª¤å¦‚ä¸‹ï¼š ä¸ºå­—å…¸çš„ ht[1] åˆ†é…ç©ºé—´ï¼Œè¿™ä¸ªå“ˆå¸Œè¡¨çš„å¤§å°å–å†³äºè¦æ‰§è¡Œçš„æ“ä½œï¼Œä»¥åŠ ht[0] å½“å‰åŒ…å«çš„é”®å€¼å¯¹æ•°é‡ï¼ˆå³ ht[0].usedï¼‰ï¼š å¦‚æœæ‰§è¡Œæ‰©å±•æ“ä½œï¼Œé‚£ä¹ˆ ht[1] çš„å¤§å°ä¸ºç¬¬ä¸€ä¸ªå¤§äºç­‰äº ht[0].used * 2 çš„ $2^n$ã€‚ å¦‚æœæ‰§è¡Œæ”¶ç¼©æ“ä½œï¼Œé‚£ä¹ˆ ht[1] çš„å¤§å°ä¸ºç¬¬ä¸€ä¸ªå¤§äºç­‰äº ht[0].used çš„ $2^n$ã€‚ å°†ä¿å­˜åœ¨ ht[0] ä¸­çš„æ‰€æœ‰é”®å€¼å¯¹ rehash åˆ° ht[1] ä¸Šé¢ï¼šrehash æŒ‡çš„æ˜¯é‡æ–°è®¡ç®—é”®çš„å“ˆå¸Œå€¼å’Œç´¢å¼•å€¼ï¼Œç„¶åå°†é”®å€¼å¯¹æ”¾åˆ° ht[1] å“ˆå¸Œè¡¨çš„æŒ‡å®šä½ç½®ä¸Šã€‚ å½“ ht[0] åŒ…å«çš„æ‰€æœ‰é”®å€¼å¯¹éƒ½è¿ç§»åˆ°äº† ht[1] ä¹‹åï¼Œé‡Šæ”¾ ht[0]ï¼Œå°† ht[1] è®¾ç½®ä¸º ht[0]ï¼Œå¹¶åœ¨ ht[1] æ–°åˆ›å»ºä¸€ä¸ªç©ºè¡¨ï¼Œä¸ºä¸‹ä¸€æ¬¡ rehash åšå‡†å¤‡ã€‚ æ¥ä¸‹æ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯æ¸è¿›å¼ rehash å§ï¼š æ‰©å±•æˆ–æ”¶ç¼©å“ˆå¸Œè¡¨éœ€è¦å°† ht[0] é‡Œé¢çš„æ‰€æœ‰é”®å€¼å¯¹ rehash åˆ° ht[1] é‡Œé¢ï¼Œ ä½†æ˜¯ï¼Œ è¿™ä¸ª rehash åŠ¨ä½œå¹¶ä¸æ˜¯ä¸€æ¬¡æ€§ã€é›†ä¸­å¼åœ°å®Œæˆçš„ï¼Œ è€Œæ˜¯åˆ†å¤šæ¬¡ã€æ¸è¿›å¼åœ°å®Œæˆçš„ã€‚ è¿™æ ·åšçš„åŸå› åœ¨äºï¼Œ å¦‚æœ ht[0] é‡Œåªä¿å­˜ç€å››ä¸ªé”®å€¼å¯¹ï¼Œ é‚£ä¹ˆæœåŠ¡å™¨å¯ä»¥åœ¨ç¬é—´å°±å°†è¿™äº›é”®å€¼å¯¹å…¨éƒ¨ rehash åˆ° ht[1] ï¼› ä½†æ˜¯ï¼Œ å¦‚æœå“ˆå¸Œè¡¨é‡Œä¿å­˜çš„é”®å€¼å¯¹æ•°é‡ä¸æ˜¯å››ä¸ªï¼Œ è€Œæ˜¯å››ç™¾ä¸‡ã€å››åƒä¸‡ç”šè‡³å››äº¿ä¸ªé”®å€¼å¯¹ï¼Œ é‚£ä¹ˆè¦ä¸€æ¬¡æ€§å°†è¿™äº›é”®å€¼å¯¹å…¨éƒ¨ rehash åˆ° ht[1] çš„è¯ï¼Œ åºå¤§çš„è®¡ç®—é‡å¯èƒ½ä¼šå¯¼è‡´æœåŠ¡å™¨åœ¨ä¸€æ®µæ—¶é—´å†…åœæ­¢æœåŠ¡ã€‚ å› æ­¤ï¼Œ ä¸ºäº†é¿å… rehash å¯¹æœåŠ¡å™¨æ€§èƒ½é€ æˆå½±å“ï¼Œ æœåŠ¡å™¨ä¸æ˜¯ä¸€æ¬¡æ€§å°† ht[0] é‡Œé¢çš„æ‰€æœ‰é”®å€¼å¯¹å…¨éƒ¨ rehash åˆ° ht[1] ï¼Œ è€Œæ˜¯åˆ†å¤šæ¬¡ã€æ¸è¿›å¼åœ°å°† ht[0] é‡Œé¢çš„é”®å€¼å¯¹æ…¢æ…¢åœ° rehash åˆ° ht[1] è¿‡ç¨‹å¦‚ä¸‹ï¼š ä¸º ht[1] åˆ†é…ç©ºé—´ï¼Œ è®©å­—å…¸åŒæ—¶æŒæœ‰ ht[0] å’Œ ht[1] ä¸¤ä¸ªå“ˆå¸Œè¡¨ã€‚ åœ¨å­—å…¸ä¸­ç»´æŒä¸€ä¸ªç´¢å¼•è®¡æ•°å™¨å˜é‡ rehashidx ï¼Œ å¹¶å°†å®ƒçš„å€¼è®¾ç½®ä¸º 0 ï¼Œ è¡¨ç¤º rehash å·¥ä½œæ­£å¼å¼€å§‹ã€‚ åœ¨ rehash è¿›è¡ŒæœŸé—´ï¼Œ æ¯æ¬¡å¯¹å­—å…¸æ‰§è¡Œæ·»åŠ ã€åˆ é™¤ã€æŸ¥æ‰¾æˆ–è€…æ›´æ–°æ“ä½œæ—¶ï¼Œ ç¨‹åºé™¤äº†æ‰§è¡ŒæŒ‡å®šçš„æ“ä½œä»¥å¤–ï¼Œ è¿˜ä¼šé¡ºå¸¦å°† ht[0] å“ˆå¸Œè¡¨åœ¨ rehashidx ç´¢å¼•ä¸Šçš„æ‰€æœ‰é”®å€¼å¯¹ rehash åˆ° ht[1] ï¼Œ å½“ rehash å·¥ä½œå®Œæˆä¹‹åï¼Œ ç¨‹åºå°† rehashidx å±æ€§çš„å€¼å¢ä¸€ã€‚ éšç€å­—å…¸æ“ä½œçš„ä¸æ–­æ‰§è¡Œï¼Œ æœ€ç»ˆåœ¨æŸä¸ªæ—¶é—´ç‚¹ä¸Šï¼Œ ht[0] çš„æ‰€æœ‰é”®å€¼å¯¹éƒ½ä¼šè¢« rehash è‡³ ht[1] ï¼Œ è¿™æ—¶ç¨‹åºå°† rehashidx å±æ€§çš„å€¼è®¾ä¸º -1 ï¼Œ è¡¨ç¤º rehash æ“ä½œå·²å®Œæˆã€‚ åŸºç¡€åº•å±‚æ“ä½œ123456789101112131415161718192021222324252627282930313233343536373839404142434445// ä½¿ç”¨ dictType ä¸­çš„ valDestructor æ¥é‡Šæ”¾ entry èŠ‚ç‚¹ val å€¼#define dictFreeVal(d, entry) \\ if ((d)->type->valDestructor) \\ (d)->type->valDestructor((d)->privdata, (entry)->v.val)// ä¸º val èµ‹å€¼#define dictSetVal(d, entry, _val_) do { \\ if ((d)->type->valDup) \\ (entry)->v.val = (d)->type->valDup((d)->privdata, _val_); \\ else \\ (entry)->v.val = (_val_); \\} while(0)// ä¸º v.s64 èµ‹å€¼#define dictSetSignedIntegerVal(entry, _val_) \\ do { (entry)->v.s64 = _val_; } while(0)// ä¸º v.u64 èµ‹å€¼#define dictSetUnsignedIntegerVal(entry, _val_) \\ do { (entry)->v.u64 = _val_; } while(0)// ä¸º v.d èµ‹å€¼#define dictSetDoubleVal(entry, _val_) \\ do { (entry)->v.d = _val_; } while(0)// ä½¿ç”¨ dict ä¸­ type çš„ valDestructor æ¥é‡Šæ”¾ entry èŠ‚ç‚¹çš„key#define dictFreeKey(d, entry) \\ if ((d)->type->keyDestructor) \\ (d)->type->keyDestructor((d)->privdata, (entry)->key)// ä¸º entry ä¸­çš„ key èµ‹å€¼#define dictSetKey(d, entry, _key_) do { \\ if ((d)->type->keyDup) \\ (entry)->key = (d)->type->keyDup((d)->privdata, _key_); \\ else \\ (entry)->key = (_key_); \\} while(0)// å¯¹ä¸¤ä¸ª key è¿›è¡Œæ¯”è¾ƒ#define dictCompareKeys(d, key1, key2) \\ (((d)->type->keyCompare) ? \\ (d)->type->keyCompare((d)->privdata, key1, key2) : \\ (key1) == (key2))#define dictHashKey(d, key) (d)->type->hashFunction(key)#define dictGetKey(he) ((he)->key)#define dictGetVal(he) ((he)->v.val)#define dictGetSignedIntegerVal(he) ((he)->v.s64)#define dictGetUnsignedIntegerVal(he) ((he)->v.u64)#define dictGetDoubleVal(he) ((he)->v.d)#define dictSlots(d) ((d)->ht[0].size+(d)->ht[1].size)#define dictSize(d) ((d)->ht[0].used+(d)->ht[1].used)#define dictIsRehashing(d) ((d)->rehashidx != -1) APIæ„å»ºä»¥åŠåˆå§‹åŒ– 1234567891011121314151617181920212223242526static void _dictReset(dictht *ht){ ht->table = NULL; ht->size = 0; ht->sizemask = 0; ht->used = 0;}dict *dictCreate(dictType *type, void *privDataPtr){ dict *d = zmalloc(sizeof(*d)); _dictInit(d,type,privDataPtr); return d;}int _dictInit(dict *d, dictType *type, void *privDataPtr){ _dictReset(&d->ht[0]); _dictReset(&d->ht[1]); d->type = type; d->privdata = privDataPtr; d->rehashidx = -1; d->iterators = 0; return DICT_OK;} è¿™ä¸‰ä¸ªå‡½æ•°ä¸éš¾çœ‹æ‡‚ï¼Œç¬¬ä¸€ä¸ªç”¨æ¥å¯¹ç»™å®šçš„ dictht è¿›è¡Œé‡ç½®ï¼Œç¬¬ä¸‰ä¸ªä½¿ç”¨ä¸€ä¸ªç»™å®šçš„ dictType ä»¥åŠä¸€ä¸ªç§æœ‰æ•°æ®æŒ‡é’ˆ privDataPtr æ¥åˆå§‹åŒ–ä¸€ä¸ª dicthtã€‚ç¬¬äºŒä¸ªæ˜¯åˆ›å»ºå‡½æ•°ï¼Œè°ƒç”¨ zmalloc å‡½æ•°æ¥åˆ†é…ä¸€ä¸ª dictï¼Œå¹¶è¿›è¡Œåˆå§‹åŒ–ã€‚ ææ„ï¼š 123void dictRelease(dict *d);int _dictClear(dict *d, dictht *ht, void(callback)(void *));void dictEmpty(dict* d, void(callbacl)(void*)); _dictClear æ˜¯æ•´ä¸ªçš„å…³é”®ï¼ŒdictRelease å’Œ dictEmpty çš„åŒºåˆ«åœ¨äºæ˜¯å¦é‡Šæ”¾æ‰å“ˆå¸Œè¡¨ï¼Œå‰è€…ä¼šé‡Šæ”¾è€Œåè€…åªæ˜¯æ¸…é™¤å…ƒç´ ï¼Œæˆ‘ä»¬é‡ç‚¹æ¥å…³æ³¨ä¸€ä¸‹ _dictClear å‡½æ•°ï¼š 12345678910111213141516171819202122232425int _dictClear(dict *d, dictht *ht, void(callback)(void *)) { unsigned long i; /* Free all the elements */ for (i = 0; i < ht->size && ht->used > 0; i++) { dictEntry *he, *nextHe; if (callback && (i & 65535) == 0) callback(d->privdata); if ((he = ht->table[i]) == NULL) continue; while(he) { nextHe = he->next; dictFreeKey(d, he); dictFreeVal(d, he); zfree(he); ht->used--; he = nextHe; } } /* Free the table and the allocated cache structure */ zfree(ht->table); /* Re-initialize the table */ _dictReset(ht); return DICT_OK; /* never fails */} æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä»–ä¼ å…¥äº†ä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œé‚£ä¹ˆæ¯æ¸…ç©º $65536$ ä¸ªæ¡¶æ—¶ï¼Œä¼šè°ƒç”¨è¿™ä¸ªå›è°ƒå‡½æ•°ï¼Œå¯¹æ­¤ï¼Œä½œè€…ç»™å‡ºçš„ç†ç”±æ˜¯ï¼š dict.c: added optional callback to dictEmpty().Redis hash table implementation has many non-blocking fearures like incremental rehashing, however while deleting a large hash table there was no way to have a callback called to do some incremental work.This commit adds this support, as an optiona callback argument to dictEmtpy() that is currently called at a fixed interval (one time every 65k deletions) å¥½å§ï¼Œçœ‹çš„ä¸æ˜¯å¾ˆæ‡‚ï¼Œç¿»è¯‘è¿‡æ¥æ˜¯ï¼šåœ¨ Redis çš„å“ˆå¸Œè¡¨æ“ä½œå¾ˆå¤šçš„æ˜¯ä»¥éé˜»å¡çš„æ–¹å¼è¿›è¡Œçš„ï¼Œä½†æ˜¯é‡Šæ”¾ä¸æ¸…ç©ºçš„æ“ä½œå´æ˜¯ ä»¥é˜»å¡çš„æ–¹å¼è¿›è¡Œçš„ï¼Œå½“åˆ é™¤ä¸€ä¸ªå¾ˆå¤§çš„å“ˆå¸Œè¡¨æ—¶ï¼Œç¼ºå°‘ä¸€ç§å¢é‡é€æ­¥æ‰§è¡ŒæŸäº›æ“ä½œçš„æœºåˆ¶ã€‚ å› æ­¤ï¼Œä½œè€…åœ¨è¿™æ¬¡æäº¤ä¸­å¼•å…¥äº†è¿™ä¸ªæœºåˆ¶ï¼Œå¯ä»¥åœ¨åˆ é™¤å“ˆå¸Œè¡¨æ—¶ï¼Œä»¥ä¸€ä¸ªå›ºå®šçš„é—´éš”æ¥æ‰§è¡Œå›è°ƒå‡½æ•°ã€‚ å¥½å§æˆ‘è¿˜æ˜¯ä¸æ˜ç™½ï¼Œè¿™é‡Œå€Ÿç”¨ä¸€ä¸‹çŸ¥ä¹ä¸€ç¯‡æ–‡ç« ä¸¾çš„ä¾‹å­ï¼š","link":"/2021/02/10/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Amap/"}],"tags":[{"name":"MapReduce","slug":"MapReduce","link":"/tags/MapReduce/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Dynamic programming","slug":"Dynamic-programming","link":"/tags/Dynamic-programming/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Environment configuration","slug":"Environment-configuration","link":"/tags/Environment-configuration/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[{"name":"UML","slug":"UML","link":"/categories/UML/"},{"name":"Distributed Systems","slug":"Distributed-Systems","link":"/categories/Distributed-Systems/"},{"name":"artical","slug":"artical","link":"/categories/artical/"},{"name":"Client","slug":"Client","link":"/categories/Client/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"C++","slug":"C","link":"/categories/C/"}]}