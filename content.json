{"pages":[{"title":"about","text":"华东师范大学软件工程学生一名，目前大三了，感概自己一事无成。开个博客，以后把自己学习上的东西传一传吧。也算是对大学生活的一个交代了。","link":"/about/index.html"}],"posts":[{"title":"UML_Lec01_02","text":"建模的四个目的 帮助我们按照需要对系统进行可视化 允许我们详细说明系统的结构和行为 给出了一个指导我们构造系统的模板 对我们所做出的决策进行文档化 建模的四项基本原理 选择要创建什么模型 每一种模型可以在不同的精度级别上表示 最好的模型是与现实相关联的 单个模型是不充分的, 对每一个重要的系统最好用一组几乎独立的模型去处理","link":"/2020/07/01/UML-Lec01-02/"},{"title":"MapReduce","text":"","link":"/2021/01/28/MapReduce/"},{"title":"UML_Lec02_b1","text":"UML 构造块$UML$ 事物 结构事物 类 接口 协作 用例 主动类 节点 构件 制品 行为事物 交互 状态机 活动 分组事物 包 注释事物 注释 关系 依赖 关联 泛化 实现 图 类图 对象图 顺序图 通信图 构件图 活动图 制品图 包图 时序图 用例图 状态图 部署图 交互概览图 对系统的体系结构建模$”4+1”$ view","link":"/2020/07/01/UML-Lec02-b1/"},{"title":"Redis数据类型：string","text":"写在前面寒假在家无聊，就想着看看 Redis5.0 的源码，刚好在知乎也看见一个写的不错的笔记，就顺着它的学习路线看代码了 Redis 是什么？Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、分布式、可持久性的键值对存储数据库（wiki 百科）。 Redis 支持哪些数据类型？ 字符串 字符串列表 无序不重复的字符串集合 有序不重复的字符串集合 键、值都为字符串的哈希表 持久化Redis 一般将全部的数据都存储在内存中，目前通过两种方法实现持久化： 快照，一种半持久内用模式。不时地将数据集以异步的方式从内存以 RDB 格式写入硬盘。 1.1 版本开始使用更安全的 AOF 格式替代，一种只能追加的日志类型。将数据集修改操作记录起来。Redis 能够在后台对只可追加的记录作修改来避免无限增长的日志 同步Redis 支持主从同步。数据可以从主服务器向任意数量的服务器上同步，从服务器可以使关联其他从服务器的主服务器，这使得 Redis 可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。（讲道理这些我现在也不是很懂。。。） 性能当数据依赖不再需要，Redis这种基于内存的性质，与在执行一个事务时将每个变化都写入硬盘的数据库系统相比就显得执行效率非常高。写与读操作速度没有明显差别 Redis 中的 string —— sdshdr数据类型Redis5.0 中定义了五种 string 类型： sdshdr5 sdshdr8 sdshdr16 sdshdr32 sdshdr64 没错，后面的数字后缀代表了能存储的字符串的最大长度。我们先来看后面四种，他们都具有相同的结构： 123456struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; // 已使用长度 uint8_t alloc; // 总的大小 unsigned char flags; // 第三位记录类型，高五位无用处 char buf[]; // 实际字符缓存}; 所以，sdshdr 类型的结构图如下： 图源： 也就是说，sdshdr 在内存中的格式为一个 Header 字段加上一段连续内存。sds 就是实际字符串的第一个字节。 由于只有 5 种类型，所以用一个 unsigned char 类型足够描述该种 sdshdr 类型，Redis 中定义了几种 type: 1234567#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7#define SDS_TYPE_BITS 3 显然，通过 flags 字段与 SDS_TYPE_MASK 做位与运算，我们可以得到其类型，而由于结构体使用的是非对齐类型（__attribute__ ((__packed__))），所以，我们直接通过访问 s[-1] 即可获得其头部信息。（讲道理我看到这个也傻了，这不是 runtime error 吗？但是转头一想，里面的数字不过是个偏移量罢了，只要你访问的那段内存是有效的，又怎么会产生段错误呢？） 现在我们来看看 sdshdr5 吧，他的结构如下： 12345struct __attribute__ ((__packed__)) sdshdr5{ unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[];}; 这样看上去，好像 sdshdr5 就是为了那些较短的字符串（不超过 32 个字节）准备的吧，像是一种静态的类型。对此，Redis 的作者也给出了建议： Don't use TYPE 5 if strings are going to be reallocated, since it sucks not having a free space left field. （谁会给 32 个字节的东西重新分配大小呢？） 通用底层操作在源码中，我们可以看到许多的宏定义： 1#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) 讲道理 struct sdshdr##T 是啥意思我真不明白，也没找到，我们结合使用了这个宏定义的函数来看看： 12345678910111213141516static inline size_t sdslen(const sds s) { unsigned char flags = s[-1]; switch(flags&SDS_TYPE_MASK) { case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)->len; case SDS_TYPE_16: return SDS_HDR(16,s)->len; case SDS_TYPE_32: return SDS_HDR(32,s)->len; case SDS_TYPE_64: return SDS_HDR(64,s)->len; } return 0;} 从名字不难得出，这就是返回 string 长度的，也就是 Header 中的 len 字段，注意传递进来的 sds 就是 char * 。 很明显，我们需要通过传递进来的 sds 数据得到对应的 Header 指针，这样我们才能访问 len 字段，那上面的式子就好理解了啊！##T 应该是被替换成了相应的数字，很巧妙的设计！因为结构体中的 char buf[] 是不占内存的，这样我们就直接访问到了 Header 的第一个字节，后面代码中很多地方都巧妙地利用了这一点。 1#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); 这一句相比也很明白了，定义了一个全局变量 sh，他能指向对应字符串的 Header 字段的第一个字节。 接下来就是一些字面意思的函数了： 1static inline size_t sdsavail(const sds s) 计算还有多少可用空间 1static inline void sdssetlen(sds s, size_t newlen) 设置新长度 1static inline void sdsinclen(sds s, size_t inc) 增加长度 1static inline size_t sdsalloc(const sds s) 得到总空间 1static inline void sdssetalloc(sds s, size_t newlen) 重置总空间 各种操作函数123static inline char sdsReqType(size_t string_size);static inline int sdsHdrSzie(char type);static inline size_t sdsTypeMaxSize(char type) 这是位与 src/sds.c 中的两个静态函数，分别用于返回一个特定 HeaderType的头部结构体长度、根据一个 string_size 的长度，返回合适的 HeaderType、以及根据 type 返回最大容量。 1sds _sdsnewlen(const void *init, size_t initlen, int trymalloc); 这是根据给定的 init 指针和 initlen 长度 来创建一个 sds 的函数，他的实现还是比较复杂的，具体描述如下： 我们根据给定的长度返回一个 HeaderType，比如：5，8，16，32 或者 64，然后对一个 void * 类型的变量进行初始化，长度为 initlen+hdrlen+1，加一是有讲究的，因为在 Redis 中 sds 总是以 '\\0' 作为结尾的，所以需要多分配一个字节的内存，哪有的小伙伴就有疑问了，要是数据中出现了 '\\0' 怎么办？这点完全不用担心，因为我们有 len 字段啊。之后我们会初始化 Header 中的各个字段，并将 init 中的内容拷贝到 sds 的缓冲区，以 '\\0' 结尾。 12345678910111213141516171819202122sds sdsnewlen(const void *init, size_t initlen) { return _sdsnewlen(init, initlen, 0);}sds sdstrynewlen(const void *init, size_t initlen) { return _sdsnewlen(init, initlen, 1);}/* Create an empty (zero length) sds string. Even in this case the string * always has an implicit null term. */sds sdsempty(void) { return sdsnewlen(\"\",0);}/* Create a new sds string starting from a null terminated C string. */sds sdsnew(const char *init) { size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);}/* Duplicate an sds string. */sds sdsdup(const sds s) { return sdsnewlen(s, sdslen(s));} 这些函数都很简单，对着上面看就 ok 了，但是有关内存分配我其实并没有讲，这一块确实比较大，我打算以后单独拎出来。 接下来我们看以个比较有意思的函数 1sds sdsMakeRoomFor(sds s, size_t addlen); 这个接口用于给一个给定的字符串扩容，可以确保用户在调用这个接口之后，可以向缓存之中续写 addlen 个字节的内容，但是这个操作不会改变已经使用的缓存的大小，也就是不会改变 sdslen 调用的结果。这个函数有点儿复杂，我就不讲码德直接上代码了。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh, *newsh; // 计算剩余空间 size_t avail = sdsavail(s); size_t len, newlen; char type, oldtype = s[-1] & SDS_TYPE_MASK; int hdrlen; size_t usable; /* 如果剩余空间足够的话，就原封不动返回 */ if (avail >= addlen) return s; // 参数字符串长度 len = sdslen(s); // 获取 Header 指针 sh = (char*)s-sdsHdrSize(oldtype); newlen = (len+addlen); // 这里的目的是减少多次扩容带来开销，索性一次给多点，1024 * 1024，也就是 1MB if (newlen < SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; // 获得新类型 type = sdsReqType(newlen); // 提示好好看，就是别用 sdshdr5 /* Don't use type 5: the user is appending to the string and type 5 is * not able to remember empty space, so sdsMakeRoomFor() must be called * at every appending operation. */ if (type == SDS_TYPE_5) type = SDS_TYPE_8; hdrlen = sdsHdrSize(type); // 没有引发升级 if (oldtype==type) { newsh = s_realloc_usable(sh, hdrlen+newlen+1, &usable); if (newsh == NULL) return NULL; s = (char*)newsh+hdrlen; } else { // 升级了的话会构造一个新的 sds /* Since the header size changes, need to move the string forward, * and can't use realloc */ newsh = s_malloc_usable(hdrlen+newlen+1, &usable); if (newsh == NULL) return NULL; memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh+hdrlen; s[-1] = type; sdssetlen(s, len); } usable = usable-hdrlen-1; if (usable > sdsTypeMaxSize(type)) usable = sdsTypeMaxSize(type); sdssetalloc(s, usable); return s;} 尤其是最后一点，升级将会导致分配一个新的 sds，然后返回新的指针，这也就意味着调用者无法保证作为参数传入的 sds 指针在调用结束后是否有效，对此，作者给出了建议： Don't call sdsMakeRoomFor() when obviously not needed. 剩下的就是处理内容的函数了，这些我就自个儿慢慢看了（或者咕掉），都不是很复杂，类似于 C 中的一些处理函数，只不过要注意处理 Header 字段。","link":"/2021/02/09/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Astring/"},{"title":"UML-Lec03","text":"四种关系 关联关系 实线+无箭头 依赖关系 箭头指向被依赖的一方 虚线+叉箭头 继承关系（泛化关系） 实线+空心箭头 实现关系 虚线+空心箭头 参与者与参与者 泛化关系 参与者与用例 关联关系 用例与用例 泛化关系 包含关系：基用例指向子用例 扩展关系：子用例指向基用例","link":"/2020/09/05/UML-Lec03/"},{"title":"UML_Lec02_b2","text":"$UML$ 和面向对象 $UML$ 不是面向对象的技术 $UML$ 的符号、语义可以用来描述面向对象的概念 重载和重写 重写，也叫覆盖，是指在子类中重新定义父类的函数 重载指在同一个类中出现多个同名的方法的现象，重载发生在同一个类中 多态和多态性 多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承） 序列数据类型有多种形态：字符串，列表，元组 动物有多种形态：人，🐕，🐖 多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为。 多态性的好处 增加了程序的灵活性 增加了程序的可扩展性","link":"/2020/07/02/UML-Lec02-b2/"},{"title":"UML-Lec06","text":"公共机制 修饰 注释 可见性、角色、多重性 扩充机制 构造型 标记值 约束 规格说明 公用划分 扩充机制构造型类似于已有的 UML 建模元素又是对特定问题领域具有特殊含义的新的建模元素 标记值在建模过程中， 出于某种原因需要增加一个新的构成以表达建模元素的某种特性，用花括号括起来 约束为对应的建模元素规定了一个条件，用花括号括起来 类的扩充机制 控制类 边界类 实体类 他们都是类的构造型","link":"/2020/09/05/UML-Lec06/"},{"title":"UML-Lec05","text":"类类的定义：具有相同属性、相同行为的一组对象的描述符，是真实世界事物的抽象 类的表示–责职 是类的合约或责任 一个良好定义的类应该有清晰的职责 一个类应只承担一种职责 类的职责划分的好坏，决定了设计方案的内聚性及耦合性 关系 依赖关系：说明一个事物使用另一个事物的信息和服务 泛化关系：子类和父类之间 关联关系 关联关系的修饰 名称及其方向 角色：在关联的每一端，表明和相连的类在该关联关系中的作用 多重性聚合/组合 聚合：整体有管理部分的特有的职责，空菱形 组合：整体有部分的生命，实菱形","link":"/2020/09/05/UML-Lec05/"},{"title":"electron-ipcMain.md","text":"ipcMain从主进程到渲染进程的异步通信。当在主进程中使用时，它处理从渲染进程（网页）发送出来的异步和同步信息。从渲染器进程发送的消息将发送到该模块。 发送消息也可以从主进程向渲染进程发送消息。 发送消息，事件名称为 channel 回复同步信息时，需要设置 event.returnValue 可以使用 event.sender.send() 将异步消息发回发送者。 例子： 1234567891011// 主进程const { ipcMain } = require('electron')ipcMain.on('asynchronous-message', (event, arg) => { console.log(arg) event.reply('asynchronous-reply', 'pong')})ipcMain.on('synchronous-message', (event, arg) => { console.log(arg) event.returnValue = 'pong'}) 12345678// 渲染进程const { ipaRenderer } = require('electron')console.log(ipcRenderer.sendSync('synchronous-message', 'ping'))ipcRenderer.on('asynchronous-reply', (event, arg) => { console.log(arg)})ipcRenderer.send('asynchronous-message', 'ping') 方法ipcMain.on(channel, listener) channel String listener Function event IpcMainEvent ...args any[] 监听 channel，当接收到新的消息时 listener 会以 listener(event, args) 的形式被调用。 ipcMain.once(channel, listener) channel String listener Function event IpcMainEvent ...args any[] 为事件添加一次监听器功能，仅在下次将消息发送到通道时才调用此侦听器，然后将其删除。 ipcMain.removeListener(channel, listener) channel String listener Function ...args any[] 从监听器数组中移除监听 channel 的指定 listener 。 ipcMain.removeAllListeners([channel]) channel String (optional) 删除所有监听者，或指定的 channel 的所有监听者。 ipcMain.handle(channel, listener) channel String listener Function event IpcMainInvokeEvent ...args any[] 为可调用的 IPC 添加处理程序。每当渲染器程序调用 ipcRenderer.invoke(channel, ...args) 都会调用这个处理程序。 如果 listener 返回一个 Promise ，则 Promise 的最终结果将作为对远程调用者的答复而返回。否则，listener 的返回值将用作回复的值。 1234567891011// Main processipcMain.handle('my-invokable-ipc', async (event, ...args) => { const result = await somePromise(...args) return result})// Renderer processasync () => { const result = await ipcRenderer.invoke('my-invokable-ipc', arg1, arg2) // ...} 作为第一个参数传递给处理程序的事件与传递给常规事件侦听器的事件相同，它包含有关哪些 WebContents 是调用请求源的信息。 ipcMain.handleOnce(channel, listener) channel String listener Function event IpcMainInvokeEvent ...args any[] 处理单个可调用的 IPC 消息，然后删除侦听器 ipcMain.removeHandler(channel) channel String 为 channel 删除所有处理程序。 ipcMainEvent Object extends Event frameID Integer - 发送该消息的渲染进程框架的 ID returnValue any - 将其设置为要在同步消息中返回的值 sender WebContents - 返回发送消息的 WebContents ports MessagePortMain[] - 随着消息一起传送的 MessagePort 列表 reply Function - 将 IPC 消息发送到渲染器框架的函数，该渲染器框架发送当前正在处理的原始消息，你应该使用 reply 方法回复发送的消息，以确保回复将转到正确的进程和框架。 channel String ...args any[] ipcRendererEvent 对象继承 Event frameID Integer - 发送该消息的渲染进程框架的 ID WebContents - 返回发送消息的 WebContents","link":"/2020/09/17/electron-ipcMain-md/"},{"title":"嵌套函数和闭包","text":"在 JS 中，可以在一个函数中嵌套另一个函数，内部函数对外部函数是私有的。它自身也形成了一个闭包，这意味着它自身可以拥有独立的环境与变量表达式。 一个嵌套（内部）函数可以“继承”容器（外部）函数的参数和变量，也就是说，内部函数包含外部函数的作用域。 内部函数只能在外部函数中访问 内部函数形成了一个闭包：他可以访问外部函数的参数和变量，但外部函数却不能使用它的变量和参数。 123456789function addSquares(a, b) { function square(x) { return x * x; } return square(a) + square(b);}a = addSquares(2, 3); // returns 13b = addSquares(3, 4); // returns 25c = addSquares(4, 5); // returns 41 由于内部函数形成了闭包，因此你可以调用外部函数并为外部函数和内部函数指定参数 1234567891011121314function outside(x) { function inside(y) { return x + y; } return inside;}fn_inside = outside(3); // 可以这样想：给一个函数，使它的值加3，fn_inside 成为了一个函数console.log(fn_inside);result = fn_inside(5); // returns 8result1 = outside(3)(5); // returns 8console.log(result); 保存变量一个闭包必须保存它可见作用域中所有参数和变量。因为每一次调用传入的参数都可能不同，每一次对外部函数的调用实际上重新创建了一遍这个闭包，只有当返回的 inside 没有再次被引用时，内存才会释放。 多层嵌套函数函数可以被多层嵌套，因此，闭包可以包含多个作用域；他们递归式的包含了所有包含它的函数作用域，这个称之为作用域链。 1234567891011121314function A(x) { function B(y) { console.log(111); function C(z) { console.log(x + y + z); } C(3); } console.log(333); B(2); console.log(222);}A(1); // logs 6 (1 + 2 + 3) 输出结果： 12343331116222 命名冲突当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。 123456789function outside() { var x = 5; function inside(x) { return x * 2; } return inside;}outside()(10); // returns 20 instead of 10 闭包闭包是 JavaScript 最强大的特性之一。当内部函数的生存周期大于外部函数时，外部函数中的定义的变量和函数的生存周期将比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。 1234567891011var pet = function(name) { //外部函数定义了一个变量\"name\" var getName = function() { //内部函数可以访问 外部函数定义的\"name\" return name; } //返回这个内部函数，从而将其暴露在外部函数作用域 return getName; };myPet = pet(\"Vivie\"); myPet(); // 返回结果 \"Vivie\" 使用 arguments 对象函数的实际参数会被保存在一个类似数组的 arguments 对象中。 使用 arguments 对象，你可以处理比声明的更多的参数来调用函数。这在你事先不知道会需要将多少参数传递给函数时十分有用。 例如下面这个链接字符串的函数 1234567891011function myConcat(separator) { var result = ''; // 把值初始化成一个字符串，这样就可以用来保存字符串了！！ var i; // iterate through arguments for (i = 1; i < arguments.length; i++) { result += arguments[i] + separator; } return result;}// returns \"red, orange, blue, \"myConcat(\", \", \"red\", \"orange\", \"blue\"); 函数参数默认参数在 JavaScript 中，函数参数的默认值是 undefined。 剩余参数剩余参数语法允许将不确定的参数表示为数组 123456function multiply(multiplier, ...theArgs) { return theArgs.map(x => multiplier * x);}var arr = multiply(2, 1, 2, 3);console.log(arr); // [2, 4, 6]","link":"/2020/09/15/%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/"},{"title":"正则表达式匹配","text":"题意：给你一个字符串 s 和一个字符规律 p，请你实现一个支持 '.' 和 '*' 的正则表达式匹配。12'.' 匹配任意单个字符'*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。 样例： 12345输入：s = \"aab\"p = \"c*a*b\"输出 ：true解释 ： 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 思路：很明显这道题属于动归吧？状态其实很好表示：dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符的匹配情况，转移方程的关键在于 s[i] 和 p[j]。尤其要注意 . 和 * 字符。 当 s[i] == p[j] || p[j] == '.' 时，dp[i][j] = dp[i-1][j-1； 当 p[j] == '* 时，情况就显得比较复杂了: 当 s[i] != p[j-1] && p[j-1] != '. 时，意味着 s 的前 i 个字符与 p 的前 j 和前 j-1 个字符都是不能匹配的（因为末尾不相等），所以 dp[i][j] = dp[i][j-2]； 否则，就把最后的 p[j-1],p[j] 来进行分类讨论，由于 * 代表重复 $0$ 到多次，所以这时候就很明显了，要么 $0$，次，要么多次；$0$ 次的时候：dp[i][j] = dp[i][j-2]，多次的时候：dp[i][j] = dp[i-1][j]。这二者是或的关系。 注意： 空串的情况。 初始化 dp[0][0] = 1。 解决空串比较好的一个方法是在 s 和 p 前都加一个 \"\"。 代码：1234567891011121314151617181920class Solution {public: bool isMatch(string s, string p) { s = \" \"+s; p = \" \"+p; int n = s.size(), m = p.size(); int dp[n+1][m+1]; memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for(int i = 1; i","link":"/2020/10/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"title":"暑期自训 $1$","text":"$A.\\ CF1236A$纯签 $B.\\ CF1236B$题意：有 $n$ 种礼物，每种礼物数量无限。$m$ 个可区分盒子。至少有一个盒子有礼物且每种礼物最少都要放一个。问有多少种方法。 思路：对每种礼物进行考虑，盒子有该礼物和没该礼物两种状态，这样每个盒子都能用 $0$ 和 $1$ 来表示两种状态。因为不能全空，这个时候就有 $2^m-1$ 种情况；再来考虑放礼物。不难发现，对于每个盒子来说，可以装这个礼物也可以不装，所以答案就是 $(2^m-1)^n$ 123456789101112131415161718192021222324252627282930313233343536#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i >= 1; a *= a, a %= mod; } return ans;}int main(){ cin >> n >> m; LL ans = qpow(qpow(2, m) - 1, n); cout < ans < n; int ans[maxn][maxn]; int m = n, cnt = 0; for(int i = 0; i < n; ++i) { if(i % 2 == 0) { for(int j = 0; j < n; ++j) ans[j][i] = ++cnt; } else for(int j = n - 1; j >= 0; --j) ans[j][i] = ++cnt; } for(int i = 0; i < n; ++i) for(int j = 0; j < n; ++j) printf(\"%d%c\", ans[i][j], (j == n - 1) ? '\\n' : ' '); return 0;} $G\\ CF1244A$纯签 $H\\ CF1244B$题意：两层迷宫，平行位置可以互相来往，当该位置为 $1$ 时，可以上下行走，每个格子最多走一次。问能走最多的格子的数量。 思路：当 $s[0]=’1’$ 或者 $s[n-1]=’1’$ 时，可以走完所有的格子，进而继续推导，能走多少个格子取决于的两端的 $1$ 的位置。 12345678910111213141516171819202122232425262728293031323334353637383940#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { cin >> n; cin >> s; int ans = 0; int flag = 0; vector v; for(int i = 0; i < n; ++i) if(s[i] == '1') v.push_back(i); if(!v.size()) ans = n; else { ans = max(2 * (v[0] + 1), 2 * (v.back() + 1)); ans = max(ans, 2 * (n - v[0])); ans = max(ans, 2 * (n - v.back())); } cout < ans < x >> y; d[x]++; d[y]++; if(d[x] > 2) flag = false; if(d[y] > 2) flag = false; v[x].pb(y); v[y].pb(x); } if(!flag) { puts(\"-1\"); return 0; } for(int i = 1; i","link":"/2020/06/25/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD1/"},{"title":"暑期自训2","text":"$A.\\ CF1277C$题意：给你一串括号序列，你可以选择任意一端区间进行倒置。要将其变为正则的，并且前缀中有 $k$ 个正则的，给出变换序列。 思路：先变为 $()()\\cdots()$ 形式，然后从前往后进行合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define fir first#define sec second#define ArrayDebug(a, l, r) for(int i = l; i > t; while(t--) { vector ans; scanf(\"%d%d\", &n, &k); cin >> s; for(int i = 0; i < n - 1; i += 2) { if(s[i] == '(' && s[i + 1] == ')') continue; else if(s[i] == '(' && s[i + 1] != ')') { int j = i + 2; while(j < n && s[j] == '(') ++j; reverse(s + i + 1, s + j + 1); ans.pb(mk(i + 1, j)); } else if(s[i] != '(') { int j = i + 1; while(j < n && s[j] == ')') ++j; reverse(s + i, s + j + 1); ans.pb(mk(i, j)); } } int x = n / 2 - k; int i = 1, cnt = 1; while(x--) { ans.pb(mk(i, i + cnt)); i++; cnt++; } cout < ans.size() <","link":"/2020/06/29/%E6%9A%91%E6%9C%9F%E8%87%AA%E8%AE%AD2/"},{"title":"正确配置hexo环境变量","text":"最近在 $windows$ 上搭建了 $Hexo$ 博客，出师未捷身先死吧，在配置环境变量的时候总是出问题，看了好几篇别人的博客也无济于事。最后我想，要使用 $Hexo$ 指令，应该是将一个带有 $.exe$ 后缀的文件路径加入到 $Path$ 中，于是我使用万能的 $Everything$ 搜索了 $hexo$，于是找到了 $hexo.cmd$$Windows$ 用户应该只要将这个路径加入到系统变量中的 $Path$ 即可正常使用了。","link":"/2020/06/17/%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEhexo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"title":"牛客多校02","text":"$F\\ Fake\\ Maxpooling(二维单调队列)$题意：给你一个 $nm$ 的数组，数组中的元素为 $a_{i,j}=lcm(i,j)$，再给你一个数字 $k$，求出子矩阵大小为 $kk$ 的最大值的和。 思路：这里介绍一下单调队列。单调队列，顾名思义，就是一种具有单调性的队列，一种递增，另一种递减。用单调队列来解决问题，一般都是需要得到当前区间的最小值或者最大值。 我们先考虑一维的情况，得到区间长度为 $k$ 的最大值。 举个例子：有 $7,6,8,12,9,10,3$ 七个数字，现在让你找出范围 $(i-4,i]$ 的最小值。接下来是模拟过程： 初始化为 ${0}$。 $i=1\\rightarrow{7}$$i=2\\rightarrow{6}$$i=3\\rightarrow{6,8}$$i=4\\rightarrow{6,8,12}$$i=5\\rightarrow{6,8,9}$$i=6$ 此时队列中元素 $6$ 不在范围 $(2,6]$ 中，故将 $6$ 弹出 $\\rightarrow{8,9,10}$$i=7\\rightarrow{3}$ 我们来看一道例题：洛谷 $p1866$ 题目描述：有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。我们直接套模板解决这道题吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include #include #include #define pii pairusing namespace std;int n, k;int a[1000007];deque que_max;deque que_min;vector ans_max, ans_min;int main(){ scanf(\"%d%d\", &n, &k); for(int i = 1; i","link":"/2020/07/21/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A102/"},{"title":"牛客多校03","text":"$G\\ Operating\\ on\\ a\\ Graph$题意：给定一个图，$q$ 次询问，每次询问为一个颜色 $o$，若该图上存在颜色为 $o$ 的部分，则将与该部分相邻的点涂成颜色 $o$，问最后每个点是什么颜色。 思路：首先容易想到，这个题应该可以用并查集来维护颜色信息。很直观的做法是我们把该部分相连的每一个点都更改颜色，但这样很显然会超时。我们用 $vector[i]$ 来维护与 $i$ 相邻的点，每次询问时，遍历所有与该部分相邻的点（如果属于就直接跳过），将所有属于该点祖先的边内所有点点放入颜色 $o$ 中。合并的时候要用到启发式合并，将小集合合并到大集合当中去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include #define LL long long#define mk make_pair#define pb push_back#define pii pair#define ArrayDebug(a, l, r) for(int i = l; i","link":"/2020/07/21/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A103/"},{"title":"Gotw1","text":"C++ 有多少种初始化变量的方法四种： 默认初始化 直接初始化 拷贝初始化 列表初始化 说下下面各行代码的含义123456789widget w; // (a)widget w(); // (b)widget w{}; // (c)widget w(x); // (d)widget w{x}; // (e)widget w = x; // (f)widget w = {x}; // (g)auto w = x; // (h)auto w = widget{x}; // (i) (a) 是默认初始化，调用的是 default constructor widget::widget()(b) 是个陷阱，不是变量初始化，而是一个名为 w 返回 widget 类型且不接受参数的函数的声明，令人讨厌的事，这种形式很有可能形成歧义，例如下面的代码： 123// same problem (gadget and doodad are types)//widget w( gadget(), doodad() ); // pitfall: not a variable declaration 好消息是 C++11 解决了这个问题，通过提供一种几乎在所有情况下都取代 case (b) 的语法来解决这个问题，这样我们就不必再陷入这个坑了，答案就是 case (c)(c) 是一种非常好的写法，它总是初始化变量，并且永远不会与函数声明产生歧义。(d) 和 (e) 都是直接初始化（假设 x 不是类型名）。二者都是通过 widget::widget(x)。如果 x 是 widget 类型，则调用拷贝构造函数，否则，将调用转换构造函数，注意到 (e) 创建了一个 std::initializer_list。如果 widget 有一个带 initializer_list 的构造函数，那么这个构造函数是首选； 否则，如果 widget 具有接受任何类型 x 的构造函数（可能带有转换），则使用该构造函数。使用 (e) 有以下几个好处（相较于 (d)）： 避免了歧义，因为 (e) 永远不可能是是一个函数声明 更安全，因为 (e) 不允许有损转换 12int i1( 12.345 ); // ok: toss .345, we didn't like it anywayint i2{ 12.345 }; // error: would be lossy implicit narrowing (f) 和 (g) 分别是复制初始化和复制列表初始化在 (f) 中，从概念上来讲，w 应该是通过拷贝构造函数或者移动构造函数初始化的，但必须纠正的一点是，不是出现的 = 就意味着调用的 T::operator=，它仍然是属于初始化而不是赋值。如果 x 是 widget 类型的，那么 (f) 和 (d) 是一样的，调用 widget::widget(x);（除了 explicit ctor 被调用）；如果 x 是其它类型，从概念上讲，编译器首先将 x 隐式转换为临时 widget 对象，然后从该临时右值移动构造 w，如果没有更好的移动构造函数，则使用复制构造作为“移动的缓慢方式”作为备份可用。假设隐式转换可用，(f) 的意思与 widget w(widget(x)); 相同。(g) 被称之为 copy-list-initialization，含义和 widget w{x} 相同，但注意，copy-list-initialization 不会调用 explicit ctor，只有普通的构造函数才能被调用(h) 和 (i) 都是复制初始化，他们的语义和 (f) 和 (g) 相似，但更加简单，因为 auto 保证了右手表达式的类型将被准确推导出Line (h) means the same as (d), type_of_x w(x);. Only a single copy constructor is called. This is guaranteed to stay true as the program evolves: Because line (h) does not commit to an explicit type, it is guaranteed to be both maximally efficient because there can be no conversion involved, and maximally robust under maintenance as the type of w “auto”-matically tracks the type of x which may change as the program is maintained. Line (i) is the most consistent spelling when you do want to commit to a specific type and explicitly request a conversion if needed, and once again the { } syntax happily avoids lossy narrowing conversions. In practice on most compilers, only a single constructor is called—similarly to what we saw with (f) and (g), conceptually there are two constructor calls, a converting or copy constructor to create a temporary widget{x} followed by a move to move it to w, but compilers routinely elide the latter. 这两段话来自 https://herbsutter.com/2013/05/09/gotw-1-solution/，翻译起来很累。。。","link":"/2021/11/21/Gotw1/"},{"title":"Redis数据类型：map","text":"Redis 中的哈希表毫无疑问，哈希表是一种非常重要的数据结构，在做算法题时，我们也经常用到它来实现常数级别的访问，而 Redis 作为一种 Key-Value 的内存数据库，当然少不了哈希表的实现了。 基本结构在 Redis 中，哈希表是基于链表实现的，首先看它在 src/dic.h 中定义的链表的节点结构： 12345678910typedef struct dictEntry { void * key; union { void * val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry * next;} dictEntry; 我们可以看到，value 部分是使用一个 union 来表示的，查看 union 具体内容可以看到，value 类型可以是一个 64 位整数、双精度浮点数或者一段内存。 然后我们来看哈希表的结构： 123456typedef struct dictht { dictEntry ** table; // table 是一个数组结构，每个元素都是一个 dictEntry 指针 unsigned long size; // 哈希桶的数量 unsigned long sizemask; // 桶数量的掩码 unsigned long used; // 已经使用的数量} dictht; 上过算法与数据结构的小伙伴想必也很清楚，就像在一个数组（链表）中，每个节点又单独是一条链表，就像下面这样： 图源： 其中的掩码主要是为了实现快速取余的用途，它的大小为 size-1，在 Redis 中，桶的数量一定是 $2^n$ 个，那么给定一个哈希值 $hash$ 可以使用 $hash & sizemask$ 来得到该数据落在哪一个哈希桶中。 接下来来看看字典类型特定函数，在 src/dic.h 中，定义了一个结构体，里面存储着一系列函数指针，这些对应了基础的哈希操作，看博客说这是函数式编程的思想，然而我并没有上过这课。。。 12345678typedef struct dictType { uint64_t (*hashFunction)(const void *key); //通给可定key，计算对应的哈希值 void *(*keyDup)(void *privdata, const void *key); //用于复制key的函数指针 void *(*valDup)(void *privdata, const void *obj); //用于复制value的函数指针 int (*keyCompare)(void *privdata, const void *key1, const void *key2); //两个key的比较函数 void (*keyDestructor)(void *privdata, void *key); //用于处理key的释放 void (*valDestructor)(void *privdata, void *obj); //用于处理val的释放} dictType; 在 src/server.c 中，Redis 为不同类型的哈希表给出了不同的 dictType，例如： 123456789/* Db->dict, key是sds动态字符串, vals则是Redis对象类型 */dictType dbDictType = { dictSdsHash, /* hash function */ NULL, /* key dup */ NULL, /* val dup */ dictSdsKeyCompare, /* key compare */ dictSdsDestructor, /* key destructor */ dictObjectDestructor /* val destructor */}; 有了 dictht 和 dictType，我们可以确定最终的字典结构了： 1234567typedef struct dict { dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */} dict; 字典在内存中的结构如下： 图源： 在 Redis 中，每一个字典有两个 dictht，这是为了实现 渐进式 rehash 这个概念我也不明白，看看《Redis 设计与实现》的说法吧： rehash随着操作的不断执行，哈希表保存的键值对会逐渐地增多或减少，为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。 Redis 对字典的哈希表执行 rehash 的步骤如下： 为字典的 ht[1] 分配空间，这个哈希表的大小取决于要执行的操作，以及 ht[0] 当前包含的键值对数量（即 ht[0].used）： 如果执行扩展操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 $2^n$。 如果执行收缩操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 $2^n$。 将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放到 ht[1] 哈希表的指定位置上。 当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后，释放 ht[0]，将 ht[1] 设置为 ht[0]，并在 ht[1] 新创建一个空表，为下一次 rehash 做准备。 接下来看看什么是渐进式 rehash 吧： 扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。 这样做的原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。 因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 过程如下： 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。 基础底层操作123456789101112131415161718192021222324252627282930313233343536373839404142434445// 使用 dictType 中的 valDestructor 来释放 entry 节点 val 值#define dictFreeVal(d, entry) \\ if ((d)->type->valDestructor) \\ (d)->type->valDestructor((d)->privdata, (entry)->v.val)// 为 val 赋值#define dictSetVal(d, entry, _val_) do { \\ if ((d)->type->valDup) \\ (entry)->v.val = (d)->type->valDup((d)->privdata, _val_); \\ else \\ (entry)->v.val = (_val_); \\} while(0)// 为 v.s64 赋值#define dictSetSignedIntegerVal(entry, _val_) \\ do { (entry)->v.s64 = _val_; } while(0)// 为 v.u64 赋值#define dictSetUnsignedIntegerVal(entry, _val_) \\ do { (entry)->v.u64 = _val_; } while(0)// 为 v.d 赋值#define dictSetDoubleVal(entry, _val_) \\ do { (entry)->v.d = _val_; } while(0)// 使用 dict 中 type 的 valDestructor 来释放 entry 节点的key#define dictFreeKey(d, entry) \\ if ((d)->type->keyDestructor) \\ (d)->type->keyDestructor((d)->privdata, (entry)->key)// 为 entry 中的 key 赋值#define dictSetKey(d, entry, _key_) do { \\ if ((d)->type->keyDup) \\ (entry)->key = (d)->type->keyDup((d)->privdata, _key_); \\ else \\ (entry)->key = (_key_); \\} while(0)// 对两个 key 进行比较#define dictCompareKeys(d, key1, key2) \\ (((d)->type->keyCompare) ? \\ (d)->type->keyCompare((d)->privdata, key1, key2) : \\ (key1) == (key2))#define dictHashKey(d, key) (d)->type->hashFunction(key)#define dictGetKey(he) ((he)->key)#define dictGetVal(he) ((he)->v.val)#define dictGetSignedIntegerVal(he) ((he)->v.s64)#define dictGetUnsignedIntegerVal(he) ((he)->v.u64)#define dictGetDoubleVal(he) ((he)->v.d)#define dictSlots(d) ((d)->ht[0].size+(d)->ht[1].size)#define dictSize(d) ((d)->ht[0].used+(d)->ht[1].used)#define dictIsRehashing(d) ((d)->rehashidx != -1) API构建以及初始化 1234567891011121314151617181920212223242526static void _dictReset(dictht *ht){ ht->table = NULL; ht->size = 0; ht->sizemask = 0; ht->used = 0;}dict *dictCreate(dictType *type, void *privDataPtr){ dict *d = zmalloc(sizeof(*d)); _dictInit(d,type,privDataPtr); return d;}int _dictInit(dict *d, dictType *type, void *privDataPtr){ _dictReset(&d->ht[0]); _dictReset(&d->ht[1]); d->type = type; d->privdata = privDataPtr; d->rehashidx = -1; d->iterators = 0; return DICT_OK;} 这三个函数不难看懂，第一个用来对给定的 dictht 进行重置，第三个使用一个给定的 dictType 以及一个私有数据指针 privDataPtr 来初始化一个 dictht。第二个是创建函数，调用 zmalloc 函数来分配一个 dict，并进行初始化。 析构： 123void dictRelease(dict *d);int _dictClear(dict *d, dictht *ht, void(callback)(void *));void dictEmpty(dict* d, void(callbacl)(void*)); _dictClear 是整个的关键，dictRelease 和 dictEmpty 的区别在于是否释放掉哈希表，前者会释放而后者只是清除元素，我们重点来关注一下 _dictClear 函数： 12345678910111213141516171819202122232425int _dictClear(dict *d, dictht *ht, void(callback)(void *)) { unsigned long i; /* Free all the elements */ for (i = 0; i < ht->size && ht->used > 0; i++) { dictEntry *he, *nextHe; if (callback && (i & 65535) == 0) callback(d->privdata); if ((he = ht->table[i]) == NULL) continue; while(he) { nextHe = he->next; dictFreeKey(d, he); dictFreeVal(d, he); zfree(he); ht->used--; he = nextHe; } } /* Free the table and the allocated cache structure */ zfree(ht->table); /* Re-initialize the table */ _dictReset(ht); return DICT_OK; /* never fails */} 我们可以看到，他传入了一个回调函数，那么每清空 $65536$ 个桶时，会调用这个回调函数，对此，作者给出的理由是： dict.c: added optional callback to dictEmpty().Redis hash table implementation has many non-blocking fearures like incremental rehashing, however while deleting a large hash table there was no way to have a callback called to do some incremental work.This commit adds this support, as an optiona callback argument to dictEmtpy() that is currently called at a fixed interval (one time every 65k deletions) 好吧，看的不是很懂，翻译过来是：在 Redis 的哈希表操作很多的是以非阻塞的方式进行的，但是释放与清空的操作却是 以阻塞的方式进行的，当删除一个很大的哈希表时，缺少一种增量逐步执行某些操作的机制。 因此，作者在这次提交中引入了这个机制，可以在删除哈希表时，以一个固定的间隔来执行回调函数。 好吧我还是不明白，这里借用一下知乎一篇文章举的例子：","link":"/2021/02/10/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Amap/"}],"tags":[{"name":"MapReduce","slug":"MapReduce","link":"/tags/MapReduce/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Dynamic programming","slug":"Dynamic-programming","link":"/tags/Dynamic-programming/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Environment configuration","slug":"Environment-configuration","link":"/tags/Environment-configuration/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[{"name":"UML","slug":"UML","link":"/categories/UML/"},{"name":"Distributed Systems","slug":"Distributed-Systems","link":"/categories/Distributed-Systems/"},{"name":"artical","slug":"artical","link":"/categories/artical/"},{"name":"Client","slug":"Client","link":"/categories/Client/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"C++","slug":"C","link":"/categories/C/"}]}